// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: page_path.sql

package db_gen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countPagePaths = `-- name: CountPagePaths :one
SELECT
    COUNT(id)
FROM page_path
WHERE deleted > now() AT TIME ZONE 'UTC'
`

func (q *Queries) CountPagePaths(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countPagePaths)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createPagePathAndReturnId = `-- name: CreatePagePathAndReturnId :one
INSERT INTO page_path (
    id,
    created,
    modified,
    deleted,
    domain_id,
    account_id,
    parent_page_path_id,
    title,
    slug,
    is_active
) VALUES (
             uuid_generate_v4(),
             now() AT TIME ZONE 'UTC',
             now() AT TIME ZONE 'UTC',
             'infinity'::timestamp AT TIME ZONE 'UTC',
             $1, $2, $3, $4, $5, $6
         )
RETURNING id
`

type CreatePagePathAndReturnIdParams struct {
	DomainID         pgtype.UUID `db:"domain_id" json:"domainId"`
	AccountID        pgtype.UUID `db:"account_id" json:"accountId"`
	ParentPagePathID pgtype.UUID `db:"parent_page_path_id" json:"parentPagePathId"`
	Title            string      `db:"title" json:"title"`
	Slug             string      `db:"slug" json:"slug"`
	IsActive         bool        `db:"is_active" json:"isActive"`
}

func (q *Queries) CreatePagePathAndReturnId(ctx context.Context, arg CreatePagePathAndReturnIdParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, createPagePathAndReturnId,
		arg.DomainID,
		arg.AccountID,
		arg.ParentPagePathID,
		arg.Title,
		arg.Slug,
		arg.IsActive,
	)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const deletePagePath = `-- name: DeletePagePath :exec
UPDATE page_path
SET
    deleted = now() AT TIME ZONE 'UTC'
WHERE id = $1
`

func (q *Queries) DeletePagePath(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deletePagePath, id)
	return err
}

const getPagePathByDomainIdAndSlug = `-- name: GetPagePathByDomainIdAndSlug :one
SELECT id, created, modified, deleted, domain_id, account_id, parent_page_path_id, title, slug, is_active FROM page_path
WHERE domain_id = $1
  AND slug = $2
  AND deleted > now() AT TIME ZONE 'UTC'
LIMIT 1
`

type GetPagePathByDomainIdAndSlugParams struct {
	DomainID pgtype.UUID `db:"domain_id" json:"domainId"`
	Slug     string      `db:"slug" json:"slug"`
}

func (q *Queries) GetPagePathByDomainIdAndSlug(ctx context.Context, arg GetPagePathByDomainIdAndSlugParams) (PagePath, error) {
	row := q.db.QueryRow(ctx, getPagePathByDomainIdAndSlug, arg.DomainID, arg.Slug)
	var i PagePath
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Modified,
		&i.Deleted,
		&i.DomainID,
		&i.AccountID,
		&i.ParentPagePathID,
		&i.Title,
		&i.Slug,
		&i.IsActive,
	)
	return i, err
}

const getPagePathByDomainIdParentPagePathIdAndSlug = `-- name: GetPagePathByDomainIdParentPagePathIdAndSlug :one
SELECT id, created, modified, deleted, domain_id, account_id, parent_page_path_id, title, slug, is_active FROM page_path
WHERE domain_id = $1
  AND slug = $2
  AND parent_page_path_id = $3
  AND deleted > now() AT TIME ZONE 'UTC'
LIMIT 1
`

type GetPagePathByDomainIdParentPagePathIdAndSlugParams struct {
	DomainID         pgtype.UUID `db:"domain_id" json:"domainId"`
	Slug             string      `db:"slug" json:"slug"`
	ParentPagePathID pgtype.UUID `db:"parent_page_path_id" json:"parentPagePathId"`
}

func (q *Queries) GetPagePathByDomainIdParentPagePathIdAndSlug(ctx context.Context, arg GetPagePathByDomainIdParentPagePathIdAndSlugParams) (PagePath, error) {
	row := q.db.QueryRow(ctx, getPagePathByDomainIdParentPagePathIdAndSlug, arg.DomainID, arg.Slug, arg.ParentPagePathID)
	var i PagePath
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Modified,
		&i.Deleted,
		&i.DomainID,
		&i.AccountID,
		&i.ParentPagePathID,
		&i.Title,
		&i.Slug,
		&i.IsActive,
	)
	return i, err
}

const getPagePathByDomainIdRootPathAndSlug = `-- name: GetPagePathByDomainIdRootPathAndSlug :one
SELECT id, created, modified, deleted, domain_id, account_id, parent_page_path_id, title, slug, is_active FROM page_path
WHERE domain_id = $1
  AND slug = $2
  AND parent_page_path_id IS NULL
  AND deleted > now() AT TIME ZONE 'UTC'
LIMIT 1
`

type GetPagePathByDomainIdRootPathAndSlugParams struct {
	DomainID pgtype.UUID `db:"domain_id" json:"domainId"`
	Slug     string      `db:"slug" json:"slug"`
}

func (q *Queries) GetPagePathByDomainIdRootPathAndSlug(ctx context.Context, arg GetPagePathByDomainIdRootPathAndSlugParams) (PagePath, error) {
	row := q.db.QueryRow(ctx, getPagePathByDomainIdRootPathAndSlug, arg.DomainID, arg.Slug)
	var i PagePath
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Modified,
		&i.Deleted,
		&i.DomainID,
		&i.AccountID,
		&i.ParentPagePathID,
		&i.Title,
		&i.Slug,
		&i.IsActive,
	)
	return i, err
}

const getPagePathById = `-- name: GetPagePathById :one
SELECT id, created, modified, deleted, domain_id, account_id, parent_page_path_id, title, slug, is_active FROM page_path
WHERE id = $1
  AND deleted > now() AT TIME ZONE 'UTC'
LIMIT 1
`

func (q *Queries) GetPagePathById(ctx context.Context, id pgtype.UUID) (PagePath, error) {
	row := q.db.QueryRow(ctx, getPagePathById, id)
	var i PagePath
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Modified,
		&i.Deleted,
		&i.DomainID,
		&i.AccountID,
		&i.ParentPagePathID,
		&i.Title,
		&i.Slug,
		&i.IsActive,
	)
	return i, err
}

const listAllPagePathsByParentPagePathIdAsc = `-- name: ListAllPagePathsByParentPagePathIdAsc :many
SELECT id, created, modified, deleted, domain_id, account_id, parent_page_path_id, title, slug, is_active FROM page_path
WHERE deleted > now() AT TIME ZONE 'UTC'
  AND parent_page_path_id = $1
ORDER BY title
`

func (q *Queries) ListAllPagePathsByParentPagePathIdAsc(ctx context.Context, parentPagePathID pgtype.UUID) ([]PagePath, error) {
	rows, err := q.db.Query(ctx, listAllPagePathsByParentPagePathIdAsc, parentPagePathID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PagePath
	for rows.Next() {
		var i PagePath
		if err := rows.Scan(
			&i.ID,
			&i.Created,
			&i.Modified,
			&i.Deleted,
			&i.DomainID,
			&i.AccountID,
			&i.ParentPagePathID,
			&i.Title,
			&i.Slug,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLinksAtRoot = `-- name: ListLinksAtRoot :many
SELECT id, created, modified, deleted, domain_id, account_id, parent_page_path_id, title, slug, is_active FROM page_path
WHERE deleted > now() AT TIME ZONE 'UTC'
  AND domain_id = $1
  AND parent_page_path_id IS NULL
ORDER BY 'title'::text
`

func (q *Queries) ListLinksAtRoot(ctx context.Context, domainID pgtype.UUID) ([]PagePath, error) {
	rows, err := q.db.Query(ctx, listLinksAtRoot, domainID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PagePath
	for rows.Next() {
		var i PagePath
		if err := rows.Scan(
			&i.ID,
			&i.Created,
			&i.Modified,
			&i.Deleted,
			&i.DomainID,
			&i.AccountID,
			&i.ParentPagePathID,
			&i.Title,
			&i.Slug,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLinksByParentId = `-- name: ListLinksByParentId :many
SELECT id, created, modified, deleted, domain_id, account_id, parent_page_path_id, title, slug, is_active FROM page_path
WHERE deleted > now() AT TIME ZONE 'UTC'
  AND domain_id = $1
  AND parent_page_path_id = $2
ORDER BY 'title'::text
`

type ListLinksByParentIdParams struct {
	DomainID         pgtype.UUID `db:"domain_id" json:"domainId"`
	ParentPagePathID pgtype.UUID `db:"parent_page_path_id" json:"parentPagePathId"`
}

func (q *Queries) ListLinksByParentId(ctx context.Context, arg ListLinksByParentIdParams) ([]PagePath, error) {
	rows, err := q.db.Query(ctx, listLinksByParentId, arg.DomainID, arg.ParentPagePathID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PagePath
	for rows.Next() {
		var i PagePath
		if err := rows.Scan(
			&i.ID,
			&i.Created,
			&i.Modified,
			&i.Deleted,
			&i.DomainID,
			&i.AccountID,
			&i.ParentPagePathID,
			&i.Title,
			&i.Slug,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPagePathsByDomainIdAndParentPagePathIdAsc = `-- name: ListPagePathsByDomainIdAndParentPagePathIdAsc :many
SELECT id, created, modified, deleted, domain_id, account_id, parent_page_path_id, title, slug, is_active FROM page_path
WHERE deleted > now() AT TIME ZONE 'UTC'
    AND domain_id = $1
    AND parent_page_path_id = $2
ORDER BY $3::text
OFFSET ($4::int - 1) * $5::int
    FETCH NEXT $5 ROWS ONLY
`

type ListPagePathsByDomainIdAndParentPagePathIdAscParams struct {
	DomainID          pgtype.UUID `db:"domain_id" json:"domainId"`
	ParentPagePathID  pgtype.UUID `db:"parent_page_path_id" json:"parentPagePathId"`
	SortBy            string      `db:"sort_by" json:"sortBy"`
	RequestedPage     int32       `db:"requested_page" json:"requestedPage"`
	RequestedPageSize int32       `db:"requested_page_size" json:"requestedPageSize"`
}

func (q *Queries) ListPagePathsByDomainIdAndParentPagePathIdAsc(ctx context.Context, arg ListPagePathsByDomainIdAndParentPagePathIdAscParams) ([]PagePath, error) {
	rows, err := q.db.Query(ctx, listPagePathsByDomainIdAndParentPagePathIdAsc,
		arg.DomainID,
		arg.ParentPagePathID,
		arg.SortBy,
		arg.RequestedPage,
		arg.RequestedPageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PagePath
	for rows.Next() {
		var i PagePath
		if err := rows.Scan(
			&i.ID,
			&i.Created,
			&i.Modified,
			&i.Deleted,
			&i.DomainID,
			&i.AccountID,
			&i.ParentPagePathID,
			&i.Title,
			&i.Slug,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPagePathsByDomainIdAndParentPagePathIdDesc = `-- name: ListPagePathsByDomainIdAndParentPagePathIdDesc :many
SELECT id, created, modified, deleted, domain_id, account_id, parent_page_path_id, title, slug, is_active FROM page_path
WHERE deleted > now() AT TIME ZONE 'UTC'
  AND domain_id = $1
  AND parent_page_path_id = $2
ORDER BY $3::text DESC
OFFSET ($4::int - 1) * $5::int
    FETCH NEXT $5 ROWS ONLY
`

type ListPagePathsByDomainIdAndParentPagePathIdDescParams struct {
	DomainID          pgtype.UUID `db:"domain_id" json:"domainId"`
	ParentPagePathID  pgtype.UUID `db:"parent_page_path_id" json:"parentPagePathId"`
	SortBy            string      `db:"sort_by" json:"sortBy"`
	RequestedPage     int32       `db:"requested_page" json:"requestedPage"`
	RequestedPageSize int32       `db:"requested_page_size" json:"requestedPageSize"`
}

func (q *Queries) ListPagePathsByDomainIdAndParentPagePathIdDesc(ctx context.Context, arg ListPagePathsByDomainIdAndParentPagePathIdDescParams) ([]PagePath, error) {
	rows, err := q.db.Query(ctx, listPagePathsByDomainIdAndParentPagePathIdDesc,
		arg.DomainID,
		arg.ParentPagePathID,
		arg.SortBy,
		arg.RequestedPage,
		arg.RequestedPageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PagePath
	for rows.Next() {
		var i PagePath
		if err := rows.Scan(
			&i.ID,
			&i.Created,
			&i.Modified,
			&i.Deleted,
			&i.DomainID,
			&i.AccountID,
			&i.ParentPagePathID,
			&i.Title,
			&i.Slug,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPagePathsByDomainIdAtRootAsc = `-- name: ListPagePathsByDomainIdAtRootAsc :many
SELECT id, created, modified, deleted, domain_id, account_id, parent_page_path_id, title, slug, is_active FROM page_path
WHERE deleted > now() AT TIME ZONE 'UTC'
    AND domain_id = $1
    AND parent_page_path_id IS NULL
ORDER BY $2::text
OFFSET ($3::int - 1) * $4::int
    FETCH NEXT $4 ROWS ONLY
`

type ListPagePathsByDomainIdAtRootAscParams struct {
	DomainID          pgtype.UUID `db:"domain_id" json:"domainId"`
	SortBy            string      `db:"sort_by" json:"sortBy"`
	RequestedPage     int32       `db:"requested_page" json:"requestedPage"`
	RequestedPageSize int32       `db:"requested_page_size" json:"requestedPageSize"`
}

func (q *Queries) ListPagePathsByDomainIdAtRootAsc(ctx context.Context, arg ListPagePathsByDomainIdAtRootAscParams) ([]PagePath, error) {
	rows, err := q.db.Query(ctx, listPagePathsByDomainIdAtRootAsc,
		arg.DomainID,
		arg.SortBy,
		arg.RequestedPage,
		arg.RequestedPageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PagePath
	for rows.Next() {
		var i PagePath
		if err := rows.Scan(
			&i.ID,
			&i.Created,
			&i.Modified,
			&i.Deleted,
			&i.DomainID,
			&i.AccountID,
			&i.ParentPagePathID,
			&i.Title,
			&i.Slug,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPagePathsByDomainIdAtRootDesc = `-- name: ListPagePathsByDomainIdAtRootDesc :many
SELECT id, created, modified, deleted, domain_id, account_id, parent_page_path_id, title, slug, is_active FROM page_path
WHERE deleted > now() AT TIME ZONE 'UTC'
    AND domain_id = $1
    AND parent_page_path_id IS NULL
ORDER BY $2::text DESC
OFFSET ($3::int - 1) * $4::int
    FETCH NEXT $4 ROWS ONLY
`

type ListPagePathsByDomainIdAtRootDescParams struct {
	DomainID          pgtype.UUID `db:"domain_id" json:"domainId"`
	SortBy            string      `db:"sort_by" json:"sortBy"`
	RequestedPage     int32       `db:"requested_page" json:"requestedPage"`
	RequestedPageSize int32       `db:"requested_page_size" json:"requestedPageSize"`
}

func (q *Queries) ListPagePathsByDomainIdAtRootDesc(ctx context.Context, arg ListPagePathsByDomainIdAtRootDescParams) ([]PagePath, error) {
	rows, err := q.db.Query(ctx, listPagePathsByDomainIdAtRootDesc,
		arg.DomainID,
		arg.SortBy,
		arg.RequestedPage,
		arg.RequestedPageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PagePath
	for rows.Next() {
		var i PagePath
		if err := rows.Scan(
			&i.ID,
			&i.Created,
			&i.Modified,
			&i.Deleted,
			&i.DomainID,
			&i.AccountID,
			&i.ParentPagePathID,
			&i.Title,
			&i.Slug,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePagePath = `-- name: UpdatePagePath :one
UPDATE page_path
SET
    modified = now() AT TIME ZONE 'UTC',
    domain_id = $2,
    account_id = $3,
    parent_page_path_id = $4,
    title = $5,
    slug = $6,
    is_active = $7
WHERE id = $1
RETURNING id, created, modified, deleted, domain_id, account_id, parent_page_path_id, title, slug, is_active
`

type UpdatePagePathParams struct {
	ID               pgtype.UUID `db:"id" json:"id"`
	DomainID         pgtype.UUID `db:"domain_id" json:"domainId"`
	AccountID        pgtype.UUID `db:"account_id" json:"accountId"`
	ParentPagePathID pgtype.UUID `db:"parent_page_path_id" json:"parentPagePathId"`
	Title            string      `db:"title" json:"title"`
	Slug             string      `db:"slug" json:"slug"`
	IsActive         bool        `db:"is_active" json:"isActive"`
}

func (q *Queries) UpdatePagePath(ctx context.Context, arg UpdatePagePathParams) (PagePath, error) {
	row := q.db.QueryRow(ctx, updatePagePath,
		arg.ID,
		arg.DomainID,
		arg.AccountID,
		arg.ParentPagePathID,
		arg.Title,
		arg.Slug,
		arg.IsActive,
	)
	var i PagePath
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Modified,
		&i.Deleted,
		&i.DomainID,
		&i.AccountID,
		&i.ParentPagePathID,
		&i.Title,
		&i.Slug,
		&i.IsActive,
	)
	return i, err
}
