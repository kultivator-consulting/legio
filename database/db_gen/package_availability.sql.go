// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: package_availability.sql

package db_gen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countPackageAvailabilityByPackageId = `-- name: CountPackageAvailabilityByPackageId :one
SELECT
    COUNT(id)
FROM package_availability
WHERE package_id = $1
`

func (q *Queries) CountPackageAvailabilityByPackageId(ctx context.Context, packageID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countPackageAvailabilityByPackageId, packageID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createPackageAvailability = `-- name: CreatePackageAvailability :one
INSERT INTO package_availability (
    id,
    created,
    modified,
    package_id,
    frequency,
    start_date,
    end_date,
    excluded_dates,
    sold_out_dates
) VALUES (
             uuid_generate_v4(),
             now() AT TIME ZONE 'UTC',
             now() AT TIME ZONE 'UTC',
             $1, $2, $3, $4, $5, $6
         )
RETURNING id, created, modified, package_id, frequency, start_date, end_date, excluded_dates, sold_out_dates
`

type CreatePackageAvailabilityParams struct {
	PackageID     pgtype.UUID          `db:"package_id" json:"packageId"`
	Frequency     string               `db:"frequency" json:"frequency"`
	StartDate     pgtype.Timestamptz   `db:"start_date" json:"startDate"`
	EndDate       pgtype.Timestamptz   `db:"end_date" json:"endDate"`
	ExcludedDates []pgtype.Timestamptz `db:"excluded_dates" json:"excludedDates"`
	SoldOutDates  []pgtype.Timestamptz `db:"sold_out_dates" json:"soldOutDates"`
}

func (q *Queries) CreatePackageAvailability(ctx context.Context, arg CreatePackageAvailabilityParams) (PackageAvailability, error) {
	row := q.db.QueryRow(ctx, createPackageAvailability,
		arg.PackageID,
		arg.Frequency,
		arg.StartDate,
		arg.EndDate,
		arg.ExcludedDates,
		arg.SoldOutDates,
	)
	var i PackageAvailability
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Modified,
		&i.PackageID,
		&i.Frequency,
		&i.StartDate,
		&i.EndDate,
		&i.ExcludedDates,
		&i.SoldOutDates,
	)
	return i, err
}

const deletePackageAvailability = `-- name: DeletePackageAvailability :exec
DELETE FROM package_availability
WHERE id = $1
`

func (q *Queries) DeletePackageAvailability(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deletePackageAvailability, id)
	return err
}

const deletePackageAvailabilityByPackageId = `-- name: DeletePackageAvailabilityByPackageId :exec
DELETE FROM package_availability
WHERE package_id = $1
`

func (q *Queries) DeletePackageAvailabilityByPackageId(ctx context.Context, packageID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deletePackageAvailabilityByPackageId, packageID)
	return err
}

const getPackageAvailabilityById = `-- name: GetPackageAvailabilityById :one
SELECT id, created, modified, package_id, frequency, start_date, end_date, excluded_dates, sold_out_dates FROM package_availability
WHERE id = $1
  AND deleted > now() AT TIME ZONE 'UTC'
LIMIT 1
`

func (q *Queries) GetPackageAvailabilityById(ctx context.Context, id pgtype.UUID) (PackageAvailability, error) {
	row := q.db.QueryRow(ctx, getPackageAvailabilityById, id)
	var i PackageAvailability
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Modified,
		&i.PackageID,
		&i.Frequency,
		&i.StartDate,
		&i.EndDate,
		&i.ExcludedDates,
		&i.SoldOutDates,
	)
	return i, err
}

const getPackageAvailabilityByPackageId = `-- name: GetPackageAvailabilityByPackageId :many
SELECT id, created, modified, package_id, frequency, start_date, end_date, excluded_dates, sold_out_dates FROM package_availability
WHERE package_id = $1
`

func (q *Queries) GetPackageAvailabilityByPackageId(ctx context.Context, packageID pgtype.UUID) ([]PackageAvailability, error) {
	rows, err := q.db.Query(ctx, getPackageAvailabilityByPackageId, packageID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PackageAvailability
	for rows.Next() {
		var i PackageAvailability
		if err := rows.Scan(
			&i.ID,
			&i.Created,
			&i.Modified,
			&i.PackageID,
			&i.Frequency,
			&i.StartDate,
			&i.EndDate,
			&i.ExcludedDates,
			&i.SoldOutDates,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getValidPackageAvailabilityByDate = `-- name: GetValidPackageAvailabilityByDate :many
SELECT id, created, modified, package_id, frequency, start_date, end_date, excluded_dates, sold_out_dates FROM package_availability
WHERE package_id = $1
  AND start_date <= $2
  AND end_date >= $2
`

type GetValidPackageAvailabilityByDateParams struct {
	PackageID pgtype.UUID        `db:"package_id" json:"packageId"`
	StartDate pgtype.Timestamptz `db:"start_date" json:"startDate"`
}

func (q *Queries) GetValidPackageAvailabilityByDate(ctx context.Context, arg GetValidPackageAvailabilityByDateParams) ([]PackageAvailability, error) {
	rows, err := q.db.Query(ctx, getValidPackageAvailabilityByDate, arg.PackageID, arg.StartDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PackageAvailability
	for rows.Next() {
		var i PackageAvailability
		if err := rows.Scan(
			&i.ID,
			&i.Created,
			&i.Modified,
			&i.PackageID,
			&i.Frequency,
			&i.StartDate,
			&i.EndDate,
			&i.ExcludedDates,
			&i.SoldOutDates,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPackageAvailabilityByPackageIdAsc = `-- name: ListPackageAvailabilityByPackageIdAsc :many
SELECT id, created, modified, package_id, frequency, start_date, end_date, excluded_dates, sold_out_dates FROM package_availability
WHERE package_id = $1
ORDER BY $2::text
OFFSET ($3::int - 1) * $4::int
    FETCH NEXT $4 ROWS ONLY
`

type ListPackageAvailabilityByPackageIdAscParams struct {
	PackageID         pgtype.UUID `db:"package_id" json:"packageId"`
	SortBy            string      `db:"sort_by" json:"sortBy"`
	RequestedPage     int32       `db:"requested_page" json:"requestedPage"`
	RequestedPageSize int32       `db:"requested_page_size" json:"requestedPageSize"`
}

func (q *Queries) ListPackageAvailabilityByPackageIdAsc(ctx context.Context, arg ListPackageAvailabilityByPackageIdAscParams) ([]PackageAvailability, error) {
	rows, err := q.db.Query(ctx, listPackageAvailabilityByPackageIdAsc,
		arg.PackageID,
		arg.SortBy,
		arg.RequestedPage,
		arg.RequestedPageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PackageAvailability
	for rows.Next() {
		var i PackageAvailability
		if err := rows.Scan(
			&i.ID,
			&i.Created,
			&i.Modified,
			&i.PackageID,
			&i.Frequency,
			&i.StartDate,
			&i.EndDate,
			&i.ExcludedDates,
			&i.SoldOutDates,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPackageAvailabilityByPackageIdDesc = `-- name: ListPackageAvailabilityByPackageIdDesc :many
SELECT id, created, modified, package_id, frequency, start_date, end_date, excluded_dates, sold_out_dates FROM package_availability
WHERE package_id = $1
ORDER BY $2::text DESC
OFFSET ($3::int - 1) * $4::int
    FETCH NEXT $4 ROWS ONLY
`

type ListPackageAvailabilityByPackageIdDescParams struct {
	PackageID         pgtype.UUID `db:"package_id" json:"packageId"`
	SortBy            string      `db:"sort_by" json:"sortBy"`
	RequestedPage     int32       `db:"requested_page" json:"requestedPage"`
	RequestedPageSize int32       `db:"requested_page_size" json:"requestedPageSize"`
}

func (q *Queries) ListPackageAvailabilityByPackageIdDesc(ctx context.Context, arg ListPackageAvailabilityByPackageIdDescParams) ([]PackageAvailability, error) {
	rows, err := q.db.Query(ctx, listPackageAvailabilityByPackageIdDesc,
		arg.PackageID,
		arg.SortBy,
		arg.RequestedPage,
		arg.RequestedPageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PackageAvailability
	for rows.Next() {
		var i PackageAvailability
		if err := rows.Scan(
			&i.ID,
			&i.Created,
			&i.Modified,
			&i.PackageID,
			&i.Frequency,
			&i.StartDate,
			&i.EndDate,
			&i.ExcludedDates,
			&i.SoldOutDates,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePackageAvailability = `-- name: UpdatePackageAvailability :one
UPDATE package_availability
SET
    modified = now() AT TIME ZONE 'UTC',
    package_id = $2,
    frequency = $3,
    start_date = $4,
    end_date = $5,
    excluded_dates = $6,
    sold_out_dates = $7
WHERE id = $1
RETURNING id, created, modified, package_id, frequency, start_date, end_date, excluded_dates, sold_out_dates
`

type UpdatePackageAvailabilityParams struct {
	ID            pgtype.UUID          `db:"id" json:"id"`
	PackageID     pgtype.UUID          `db:"package_id" json:"packageId"`
	Frequency     string               `db:"frequency" json:"frequency"`
	StartDate     pgtype.Timestamptz   `db:"start_date" json:"startDate"`
	EndDate       pgtype.Timestamptz   `db:"end_date" json:"endDate"`
	ExcludedDates []pgtype.Timestamptz `db:"excluded_dates" json:"excludedDates"`
	SoldOutDates  []pgtype.Timestamptz `db:"sold_out_dates" json:"soldOutDates"`
}

func (q *Queries) UpdatePackageAvailability(ctx context.Context, arg UpdatePackageAvailabilityParams) (PackageAvailability, error) {
	row := q.db.QueryRow(ctx, updatePackageAvailability,
		arg.ID,
		arg.PackageID,
		arg.Frequency,
		arg.StartDate,
		arg.EndDate,
		arg.ExcludedDates,
		arg.SoldOutDates,
	)
	var i PackageAvailability
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Modified,
		&i.PackageID,
		&i.Frequency,
		&i.StartDate,
		&i.EndDate,
		&i.ExcludedDates,
		&i.SoldOutDates,
	)
	return i, err
}
