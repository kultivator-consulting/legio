// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: operator_product_type.sql

package db_gen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countOperatorProductTypesByOperatorId = `-- name: CountOperatorProductTypesByOperatorId :one
SELECT
    COUNT(id)
FROM operator_product_type
WHERE operator_id = $1
`

func (q *Queries) CountOperatorProductTypesByOperatorId(ctx context.Context, operatorID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countOperatorProductTypesByOperatorId, operatorID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createOperatorProductType = `-- name: CreateOperatorProductType :one
INSERT INTO operator_product_type (
    id,
    created,
    modified,
    operator_id,
    product_type_id
) VALUES (
             uuid_generate_v4(),
             now() AT TIME ZONE 'UTC',
             now() AT TIME ZONE 'UTC',
             $1, $2
         )
RETURNING id, created, modified, operator_id, product_type_id
`

type CreateOperatorProductTypeParams struct {
	OperatorID    pgtype.UUID `db:"operator_id" json:"operatorId"`
	ProductTypeID pgtype.UUID `db:"product_type_id" json:"productTypeId"`
}

func (q *Queries) CreateOperatorProductType(ctx context.Context, arg CreateOperatorProductTypeParams) (OperatorProductType, error) {
	row := q.db.QueryRow(ctx, createOperatorProductType, arg.OperatorID, arg.ProductTypeID)
	var i OperatorProductType
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Modified,
		&i.OperatorID,
		&i.ProductTypeID,
	)
	return i, err
}

const deleteOperatorProductType = `-- name: DeleteOperatorProductType :exec
DELETE FROM operator_product_type
WHERE id = $1
`

func (q *Queries) DeleteOperatorProductType(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteOperatorProductType, id)
	return err
}

const deleteOperatorProductTypeByOperatorId = `-- name: DeleteOperatorProductTypeByOperatorId :exec
DELETE FROM operator_product_type
WHERE operator_id = $1
`

func (q *Queries) DeleteOperatorProductTypeByOperatorId(ctx context.Context, operatorID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteOperatorProductTypeByOperatorId, operatorID)
	return err
}

const getOperatorProductTypeById = `-- name: GetOperatorProductTypeById :one
SELECT id, created, modified, operator_id, product_type_id FROM operator_product_type
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetOperatorProductTypeById(ctx context.Context, id pgtype.UUID) (OperatorProductType, error) {
	row := q.db.QueryRow(ctx, getOperatorProductTypeById, id)
	var i OperatorProductType
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Modified,
		&i.OperatorID,
		&i.ProductTypeID,
	)
	return i, err
}

const listOperatorProductTypesByOperatorId = `-- name: ListOperatorProductTypesByOperatorId :many
SELECT id, created, modified, operator_id, product_type_id FROM operator_product_type
WHERE operator_id = $1
`

func (q *Queries) ListOperatorProductTypesByOperatorId(ctx context.Context, operatorID pgtype.UUID) ([]OperatorProductType, error) {
	rows, err := q.db.Query(ctx, listOperatorProductTypesByOperatorId, operatorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OperatorProductType
	for rows.Next() {
		var i OperatorProductType
		if err := rows.Scan(
			&i.ID,
			&i.Created,
			&i.Modified,
			&i.OperatorID,
			&i.ProductTypeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateOperatorProductType = `-- name: UpdateOperatorProductType :one
UPDATE operator_product_type
SET
    modified = now() AT TIME ZONE 'UTC',
    operator_id = $2,
    product_type_id = $3
WHERE id = $1
RETURNING id, created, modified, operator_id, product_type_id
`

type UpdateOperatorProductTypeParams struct {
	ID            pgtype.UUID `db:"id" json:"id"`
	OperatorID    pgtype.UUID `db:"operator_id" json:"operatorId"`
	ProductTypeID pgtype.UUID `db:"product_type_id" json:"productTypeId"`
}

func (q *Queries) UpdateOperatorProductType(ctx context.Context, arg UpdateOperatorProductTypeParams) (OperatorProductType, error) {
	row := q.db.QueryRow(ctx, updateOperatorProductType, arg.ID, arg.OperatorID, arg.ProductTypeID)
	var i OperatorProductType
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Modified,
		&i.OperatorID,
		&i.ProductTypeID,
	)
	return i, err
}
