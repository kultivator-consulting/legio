// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: account.sql

package db_gen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countAccounts = `-- name: CountAccounts :one
SELECT
    COUNT(id)
FROM account
WHERE deleted > now() AT TIME ZONE 'UTC'
`

func (q *Queries) CountAccounts(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countAccounts)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAccount = `-- name: CreateAccount :one
INSERT INTO account (
    id,
    created,
    modified,
    deleted,
    first_name,
    last_name,
    access_Level,
    credit_balance,
    username,
    user_email_address,
    user_avatar_url,
    user_zone_info,
    user_locale,
    user_password,
    is_locked,
    last_login,
    reset_password_token,
    reset_password_token_expiry
) VALUES (
             uuid_generate_v4(),
             now() AT TIME ZONE 'UTC',
             now() AT TIME ZONE 'UTC',
             'infinity'::timestamp AT TIME ZONE 'UTC',
             $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14
         )
RETURNING id, created, modified, deleted, is_system, first_name, last_name, access_level, credit_balance, username, user_email_address, user_avatar_url, user_zone_info, user_locale, user_password, is_locked, last_login, reset_password_token, reset_password_token_expiry
`

type CreateAccountParams struct {
	FirstName                pgtype.Text        `db:"first_name" json:"firstName"`
	LastName                 pgtype.Text        `db:"last_name" json:"lastName"`
	AccessLevel              pgtype.Int4        `db:"access_level" json:"accessLevel"`
	CreditBalance            float64            `db:"credit_balance" json:"creditBalance"`
	Username                 string             `db:"username" json:"username"`
	UserEmailAddress         string             `db:"user_email_address" json:"userEmailAddress"`
	UserAvatarUrl            pgtype.Text        `db:"user_avatar_url" json:"userAvatarUrl"`
	UserZoneInfo             pgtype.Text        `db:"user_zone_info" json:"userZoneInfo"`
	UserLocale               pgtype.Text        `db:"user_locale" json:"userLocale"`
	UserPassword             pgtype.Text        `db:"user_password" json:"userPassword"`
	IsLocked                 bool               `db:"is_locked" json:"isLocked"`
	LastLogin                pgtype.Timestamptz `db:"last_login" json:"lastLogin"`
	ResetPasswordToken       pgtype.Text        `db:"reset_password_token" json:"resetPasswordToken"`
	ResetPasswordTokenExpiry pgtype.Timestamptz `db:"reset_password_token_expiry" json:"resetPasswordTokenExpiry"`
}

func (q *Queries) CreateAccount(ctx context.Context, arg CreateAccountParams) (Account, error) {
	row := q.db.QueryRow(ctx, createAccount,
		arg.FirstName,
		arg.LastName,
		arg.AccessLevel,
		arg.CreditBalance,
		arg.Username,
		arg.UserEmailAddress,
		arg.UserAvatarUrl,
		arg.UserZoneInfo,
		arg.UserLocale,
		arg.UserPassword,
		arg.IsLocked,
		arg.LastLogin,
		arg.ResetPasswordToken,
		arg.ResetPasswordTokenExpiry,
	)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Modified,
		&i.Deleted,
		&i.IsSystem,
		&i.FirstName,
		&i.LastName,
		&i.AccessLevel,
		&i.CreditBalance,
		&i.Username,
		&i.UserEmailAddress,
		&i.UserAvatarUrl,
		&i.UserZoneInfo,
		&i.UserLocale,
		&i.UserPassword,
		&i.IsLocked,
		&i.LastLogin,
		&i.ResetPasswordToken,
		&i.ResetPasswordTokenExpiry,
	)
	return i, err
}

const createAccountAndReturnId = `-- name: CreateAccountAndReturnId :one
INSERT INTO account (
    id,
    created,
    modified,
    deleted,
    first_name,
    last_name,
    access_Level,
    credit_balance,
    username,
    user_email_address,
    user_avatar_url,
    user_zone_info,
    user_locale,
    user_password,
    is_locked,
    last_login,
    reset_password_token,
    reset_password_token_expiry
) VALUES (
             uuid_generate_v4(),
             now() AT TIME ZONE 'UTC',
             now() AT TIME ZONE 'UTC',
             'infinity'::timestamp AT TIME ZONE 'UTC',
             $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14
         )
RETURNING id
`

type CreateAccountAndReturnIdParams struct {
	FirstName                pgtype.Text        `db:"first_name" json:"firstName"`
	LastName                 pgtype.Text        `db:"last_name" json:"lastName"`
	AccessLevel              pgtype.Int4        `db:"access_level" json:"accessLevel"`
	CreditBalance            float64            `db:"credit_balance" json:"creditBalance"`
	Username                 string             `db:"username" json:"username"`
	UserEmailAddress         string             `db:"user_email_address" json:"userEmailAddress"`
	UserAvatarUrl            pgtype.Text        `db:"user_avatar_url" json:"userAvatarUrl"`
	UserZoneInfo             pgtype.Text        `db:"user_zone_info" json:"userZoneInfo"`
	UserLocale               pgtype.Text        `db:"user_locale" json:"userLocale"`
	UserPassword             pgtype.Text        `db:"user_password" json:"userPassword"`
	IsLocked                 bool               `db:"is_locked" json:"isLocked"`
	LastLogin                pgtype.Timestamptz `db:"last_login" json:"lastLogin"`
	ResetPasswordToken       pgtype.Text        `db:"reset_password_token" json:"resetPasswordToken"`
	ResetPasswordTokenExpiry pgtype.Timestamptz `db:"reset_password_token_expiry" json:"resetPasswordTokenExpiry"`
}

func (q *Queries) CreateAccountAndReturnId(ctx context.Context, arg CreateAccountAndReturnIdParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, createAccountAndReturnId,
		arg.FirstName,
		arg.LastName,
		arg.AccessLevel,
		arg.CreditBalance,
		arg.Username,
		arg.UserEmailAddress,
		arg.UserAvatarUrl,
		arg.UserZoneInfo,
		arg.UserLocale,
		arg.UserPassword,
		arg.IsLocked,
		arg.LastLogin,
		arg.ResetPasswordToken,
		arg.ResetPasswordTokenExpiry,
	)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const deleteAccount = `-- name: DeleteAccount :exec
UPDATE account
SET
    deleted = now() AT TIME ZONE 'UTC'
WHERE id = $1
  AND is_system = false
`

func (q *Queries) DeleteAccount(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteAccount, id)
	return err
}

const getAccount = `-- name: GetAccount :one
SELECT
    id,
    created,
    modified,
    deleted,
    is_system,
    first_name,
    last_name,
    access_Level,
    credit_balance,
    username,
    user_email_address,
    user_avatar_url,
    user_zone_info,
    user_locale,
    is_locked,
    last_login,
    reset_password_token,
    reset_password_token_expiry FROM account
WHERE id = $1
  AND deleted > now() AT TIME ZONE 'UTC'
LIMIT 1
`

type GetAccountRow struct {
	ID                       pgtype.UUID        `db:"id" json:"id"`
	Created                  pgtype.Timestamptz `db:"created" json:"created"`
	Modified                 pgtype.Timestamptz `db:"modified" json:"modified"`
	Deleted                  pgtype.Timestamptz `db:"deleted" json:"deleted"`
	IsSystem                 bool               `db:"is_system" json:"isSystem"`
	FirstName                pgtype.Text        `db:"first_name" json:"firstName"`
	LastName                 pgtype.Text        `db:"last_name" json:"lastName"`
	AccessLevel              pgtype.Int4        `db:"access_level" json:"accessLevel"`
	CreditBalance            float64            `db:"credit_balance" json:"creditBalance"`
	Username                 string             `db:"username" json:"username"`
	UserEmailAddress         string             `db:"user_email_address" json:"userEmailAddress"`
	UserAvatarUrl            pgtype.Text        `db:"user_avatar_url" json:"userAvatarUrl"`
	UserZoneInfo             pgtype.Text        `db:"user_zone_info" json:"userZoneInfo"`
	UserLocale               pgtype.Text        `db:"user_locale" json:"userLocale"`
	IsLocked                 bool               `db:"is_locked" json:"isLocked"`
	LastLogin                pgtype.Timestamptz `db:"last_login" json:"lastLogin"`
	ResetPasswordToken       pgtype.Text        `db:"reset_password_token" json:"resetPasswordToken"`
	ResetPasswordTokenExpiry pgtype.Timestamptz `db:"reset_password_token_expiry" json:"resetPasswordTokenExpiry"`
}

func (q *Queries) GetAccount(ctx context.Context, id pgtype.UUID) (GetAccountRow, error) {
	row := q.db.QueryRow(ctx, getAccount, id)
	var i GetAccountRow
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Modified,
		&i.Deleted,
		&i.IsSystem,
		&i.FirstName,
		&i.LastName,
		&i.AccessLevel,
		&i.CreditBalance,
		&i.Username,
		&i.UserEmailAddress,
		&i.UserAvatarUrl,
		&i.UserZoneInfo,
		&i.UserLocale,
		&i.IsLocked,
		&i.LastLogin,
		&i.ResetPasswordToken,
		&i.ResetPasswordTokenExpiry,
	)
	return i, err
}

const getAccountByEmailAddress = `-- name: GetAccountByEmailAddress :one
SELECT id, created, modified, deleted, is_system, first_name, last_name, access_level, credit_balance, username, user_email_address, user_avatar_url, user_zone_info, user_locale, user_password, is_locked, last_login, reset_password_token, reset_password_token_expiry FROM account
WHERE user_email_address = $1
  AND deleted > now() AT TIME ZONE 'UTC'
  AND is_locked = FALSE
LIMIT 1
`

func (q *Queries) GetAccountByEmailAddress(ctx context.Context, userEmailAddress string) (Account, error) {
	row := q.db.QueryRow(ctx, getAccountByEmailAddress, userEmailAddress)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Modified,
		&i.Deleted,
		&i.IsSystem,
		&i.FirstName,
		&i.LastName,
		&i.AccessLevel,
		&i.CreditBalance,
		&i.Username,
		&i.UserEmailAddress,
		&i.UserAvatarUrl,
		&i.UserZoneInfo,
		&i.UserLocale,
		&i.UserPassword,
		&i.IsLocked,
		&i.LastLogin,
		&i.ResetPasswordToken,
		&i.ResetPasswordTokenExpiry,
	)
	return i, err
}

const getAccountById = `-- name: GetAccountById :one
SELECT id, created, modified, deleted, is_system, first_name, last_name, access_level, credit_balance, username, user_email_address, user_avatar_url, user_zone_info, user_locale, user_password, is_locked, last_login, reset_password_token, reset_password_token_expiry FROM account
WHERE id = $1
  AND deleted > now() AT TIME ZONE 'UTC'
LIMIT 1
`

func (q *Queries) GetAccountById(ctx context.Context, id pgtype.UUID) (Account, error) {
	row := q.db.QueryRow(ctx, getAccountById, id)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Modified,
		&i.Deleted,
		&i.IsSystem,
		&i.FirstName,
		&i.LastName,
		&i.AccessLevel,
		&i.CreditBalance,
		&i.Username,
		&i.UserEmailAddress,
		&i.UserAvatarUrl,
		&i.UserZoneInfo,
		&i.UserLocale,
		&i.UserPassword,
		&i.IsLocked,
		&i.LastLogin,
		&i.ResetPasswordToken,
		&i.ResetPasswordTokenExpiry,
	)
	return i, err
}

const getAccountByUsername = `-- name: GetAccountByUsername :one
SELECT id, created, modified, deleted, is_system, first_name, last_name, access_level, credit_balance, username, user_email_address, user_avatar_url, user_zone_info, user_locale, user_password, is_locked, last_login, reset_password_token, reset_password_token_expiry FROM account
WHERE username = $1
  AND deleted > now() AT TIME ZONE 'UTC'
  AND is_locked = FALSE
LIMIT 1
`

func (q *Queries) GetAccountByUsername(ctx context.Context, username string) (Account, error) {
	row := q.db.QueryRow(ctx, getAccountByUsername, username)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Modified,
		&i.Deleted,
		&i.IsSystem,
		&i.FirstName,
		&i.LastName,
		&i.AccessLevel,
		&i.CreditBalance,
		&i.Username,
		&i.UserEmailAddress,
		&i.UserAvatarUrl,
		&i.UserZoneInfo,
		&i.UserLocale,
		&i.UserPassword,
		&i.IsLocked,
		&i.LastLogin,
		&i.ResetPasswordToken,
		&i.ResetPasswordTokenExpiry,
	)
	return i, err
}

const getUnlockedAccountById = `-- name: GetUnlockedAccountById :one
SELECT id, created, modified, deleted, is_system, first_name, last_name, access_level, credit_balance, username, user_email_address, user_avatar_url, user_zone_info, user_locale, user_password, is_locked, last_login, reset_password_token, reset_password_token_expiry FROM account
WHERE id = $1
  AND deleted > now() AT TIME ZONE 'UTC'
  AND is_locked = FALSE
LIMIT 1
`

func (q *Queries) GetUnlockedAccountById(ctx context.Context, id pgtype.UUID) (Account, error) {
	row := q.db.QueryRow(ctx, getUnlockedAccountById, id)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Modified,
		&i.Deleted,
		&i.IsSystem,
		&i.FirstName,
		&i.LastName,
		&i.AccessLevel,
		&i.CreditBalance,
		&i.Username,
		&i.UserEmailAddress,
		&i.UserAvatarUrl,
		&i.UserZoneInfo,
		&i.UserLocale,
		&i.UserPassword,
		&i.IsLocked,
		&i.LastLogin,
		&i.ResetPasswordToken,
		&i.ResetPasswordTokenExpiry,
	)
	return i, err
}

const listAccounts = `-- name: ListAccounts :many
SELECT
    id,
    created,
    modified,
    deleted,
    is_system,
    first_name,
    last_name,
    access_Level,
    credit_balance,
    username,
    user_email_address,
    user_avatar_url,
    user_zone_info,
    user_locale,
    is_locked,
    last_login,
    reset_password_token,
    reset_password_token_expiry FROM account
WHERE deleted > now() AT TIME ZONE 'UTC'
ORDER BY
    CASE
        WHEN $1::text = 'created' AND $2 = 'asc' THEN $1::text END ASC,
    CASE
        WHEN $1::text = 'created' AND $2 = 'desc' THEN $1::text END DESC,
    CASE
        WHEN $1::text = 'first_name' AND $2 = 'asc' THEN $1::text END ASC,
    CASE
        WHEN $1::text = 'first_name' AND $2 = 'desc' THEN $1::text END DESC,
    CASE
        WHEN $1::text = 'last_name' AND $2 = 'asc' THEN $1::text END ASC,
    CASE
        WHEN $1::text = 'last_name' AND $2 = 'desc' THEN $1::text END DESC,
    CASE
        WHEN $1::text = 'access_Level' AND $2 = 'asc' THEN $1::text END ASC,
    CASE
        WHEN $1::text = 'access_Level' AND $2 = 'desc' THEN $1::text END DESC,
    CASE
        WHEN $1::text = 'credit_balance' AND $2 = 'asc' THEN $1::text END ASC,
    CASE
        WHEN $1::text = 'credit_balance' AND $2 = 'desc' THEN $1::text END DESC,
    CASE
        WHEN $1::text = 'username' AND $2 = 'asc' THEN $1::text END ASC,
    CASE
        WHEN $1::text = 'username' AND $2 = 'desc' THEN $1::text END DESC,
    CASE
        WHEN $1::text = 'user_email_address' AND $2 = 'asc' THEN $1::text END ASC,
    CASE
        WHEN $1::text = 'user_email_address' AND $2 = 'desc' THEN $1::text END DESC,
    CASE
        WHEN $1::text = 'is_locked' AND $2 = 'asc' THEN  $1::text END ASC,
    CASE
        WHEN $1::text = 'is_locked' AND $2 = 'desc' THEN $1::text END DESC,
    CASE
        WHEN $1::text = 'last_login' AND $2 = 'asc' THEN $1::text END ASC,
    CASE
        WHEN $1::text = 'last_login' AND $2 = 'desc' THEN $1::text END DESC

OFFSET ($3::int - 1) * $4::int
    FETCH NEXT $4 ROWS ONLY
`

type ListAccountsParams struct {
	SortBy            string      `db:"sort_by" json:"sortBy"`
	SortOrder         interface{} `db:"sort_order" json:"sortOrder"`
	RequestedPage     int32       `db:"requested_page" json:"requestedPage"`
	RequestedPageSize int32       `db:"requested_page_size" json:"requestedPageSize"`
}

type ListAccountsRow struct {
	ID                       pgtype.UUID        `db:"id" json:"id"`
	Created                  pgtype.Timestamptz `db:"created" json:"created"`
	Modified                 pgtype.Timestamptz `db:"modified" json:"modified"`
	Deleted                  pgtype.Timestamptz `db:"deleted" json:"deleted"`
	IsSystem                 bool               `db:"is_system" json:"isSystem"`
	FirstName                pgtype.Text        `db:"first_name" json:"firstName"`
	LastName                 pgtype.Text        `db:"last_name" json:"lastName"`
	AccessLevel              pgtype.Int4        `db:"access_level" json:"accessLevel"`
	CreditBalance            float64            `db:"credit_balance" json:"creditBalance"`
	Username                 string             `db:"username" json:"username"`
	UserEmailAddress         string             `db:"user_email_address" json:"userEmailAddress"`
	UserAvatarUrl            pgtype.Text        `db:"user_avatar_url" json:"userAvatarUrl"`
	UserZoneInfo             pgtype.Text        `db:"user_zone_info" json:"userZoneInfo"`
	UserLocale               pgtype.Text        `db:"user_locale" json:"userLocale"`
	IsLocked                 bool               `db:"is_locked" json:"isLocked"`
	LastLogin                pgtype.Timestamptz `db:"last_login" json:"lastLogin"`
	ResetPasswordToken       pgtype.Text        `db:"reset_password_token" json:"resetPasswordToken"`
	ResetPasswordTokenExpiry pgtype.Timestamptz `db:"reset_password_token_expiry" json:"resetPasswordTokenExpiry"`
}

func (q *Queries) ListAccounts(ctx context.Context, arg ListAccountsParams) ([]ListAccountsRow, error) {
	rows, err := q.db.Query(ctx, listAccounts,
		arg.SortBy,
		arg.SortOrder,
		arg.RequestedPage,
		arg.RequestedPageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAccountsRow
	for rows.Next() {
		var i ListAccountsRow
		if err := rows.Scan(
			&i.ID,
			&i.Created,
			&i.Modified,
			&i.Deleted,
			&i.IsSystem,
			&i.FirstName,
			&i.LastName,
			&i.AccessLevel,
			&i.CreditBalance,
			&i.Username,
			&i.UserEmailAddress,
			&i.UserAvatarUrl,
			&i.UserZoneInfo,
			&i.UserLocale,
			&i.IsLocked,
			&i.LastLogin,
			&i.ResetPasswordToken,
			&i.ResetPasswordTokenExpiry,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAccount = `-- name: UpdateAccount :one
UPDATE account
SET
    modified = now() AT TIME ZONE 'UTC',
    first_name = $2,
    last_name = $3,
    access_Level = $4,
    credit_balance = $5,
    username = $6,
    user_email_address = $7,
    user_avatar_url = $8,
    user_zone_info = $9,
    user_locale = $10,
    user_password = $11,
    is_locked = $12,
    last_login = $13,
    reset_password_token = $14,
    reset_password_token_expiry = $15
WHERE id = $1
RETURNING
    id,
    created,
    modified,
    deleted,
    first_name,
    last_name,
    access_Level,
    credit_balance,
    username,
    user_email_address,
    user_avatar_url,
    user_zone_info,
    user_locale,
    is_locked,
    last_login,
    reset_password_token,
    reset_password_token_expiry
`

type UpdateAccountParams struct {
	ID                       pgtype.UUID        `db:"id" json:"id"`
	FirstName                pgtype.Text        `db:"first_name" json:"firstName"`
	LastName                 pgtype.Text        `db:"last_name" json:"lastName"`
	AccessLevel              pgtype.Int4        `db:"access_level" json:"accessLevel"`
	CreditBalance            float64            `db:"credit_balance" json:"creditBalance"`
	Username                 string             `db:"username" json:"username"`
	UserEmailAddress         string             `db:"user_email_address" json:"userEmailAddress"`
	UserAvatarUrl            pgtype.Text        `db:"user_avatar_url" json:"userAvatarUrl"`
	UserZoneInfo             pgtype.Text        `db:"user_zone_info" json:"userZoneInfo"`
	UserLocale               pgtype.Text        `db:"user_locale" json:"userLocale"`
	UserPassword             pgtype.Text        `db:"user_password" json:"userPassword"`
	IsLocked                 bool               `db:"is_locked" json:"isLocked"`
	LastLogin                pgtype.Timestamptz `db:"last_login" json:"lastLogin"`
	ResetPasswordToken       pgtype.Text        `db:"reset_password_token" json:"resetPasswordToken"`
	ResetPasswordTokenExpiry pgtype.Timestamptz `db:"reset_password_token_expiry" json:"resetPasswordTokenExpiry"`
}

type UpdateAccountRow struct {
	ID                       pgtype.UUID        `db:"id" json:"id"`
	Created                  pgtype.Timestamptz `db:"created" json:"created"`
	Modified                 pgtype.Timestamptz `db:"modified" json:"modified"`
	Deleted                  pgtype.Timestamptz `db:"deleted" json:"deleted"`
	FirstName                pgtype.Text        `db:"first_name" json:"firstName"`
	LastName                 pgtype.Text        `db:"last_name" json:"lastName"`
	AccessLevel              pgtype.Int4        `db:"access_level" json:"accessLevel"`
	CreditBalance            float64            `db:"credit_balance" json:"creditBalance"`
	Username                 string             `db:"username" json:"username"`
	UserEmailAddress         string             `db:"user_email_address" json:"userEmailAddress"`
	UserAvatarUrl            pgtype.Text        `db:"user_avatar_url" json:"userAvatarUrl"`
	UserZoneInfo             pgtype.Text        `db:"user_zone_info" json:"userZoneInfo"`
	UserLocale               pgtype.Text        `db:"user_locale" json:"userLocale"`
	IsLocked                 bool               `db:"is_locked" json:"isLocked"`
	LastLogin                pgtype.Timestamptz `db:"last_login" json:"lastLogin"`
	ResetPasswordToken       pgtype.Text        `db:"reset_password_token" json:"resetPasswordToken"`
	ResetPasswordTokenExpiry pgtype.Timestamptz `db:"reset_password_token_expiry" json:"resetPasswordTokenExpiry"`
}

func (q *Queries) UpdateAccount(ctx context.Context, arg UpdateAccountParams) (UpdateAccountRow, error) {
	row := q.db.QueryRow(ctx, updateAccount,
		arg.ID,
		arg.FirstName,
		arg.LastName,
		arg.AccessLevel,
		arg.CreditBalance,
		arg.Username,
		arg.UserEmailAddress,
		arg.UserAvatarUrl,
		arg.UserZoneInfo,
		arg.UserLocale,
		arg.UserPassword,
		arg.IsLocked,
		arg.LastLogin,
		arg.ResetPasswordToken,
		arg.ResetPasswordTokenExpiry,
	)
	var i UpdateAccountRow
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Modified,
		&i.Deleted,
		&i.FirstName,
		&i.LastName,
		&i.AccessLevel,
		&i.CreditBalance,
		&i.Username,
		&i.UserEmailAddress,
		&i.UserAvatarUrl,
		&i.UserZoneInfo,
		&i.UserLocale,
		&i.IsLocked,
		&i.LastLogin,
		&i.ResetPasswordToken,
		&i.ResetPasswordTokenExpiry,
	)
	return i, err
}

const updateAccountLastLogin = `-- name: UpdateAccountLastLogin :exec
UPDATE account
SET
    last_login = now() AT TIME ZONE 'UTC'
WHERE id = $1
`

func (q *Queries) UpdateAccountLastLogin(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, updateAccountLastLogin, id)
	return err
}

const updateAccountResetPasswordByToken = `-- name: UpdateAccountResetPasswordByToken :one
UPDATE account
SET
    modified = now() AT TIME ZONE 'UTC',
    user_password = $2,
    reset_password_token = NULL
WHERE reset_password_token = $1
    AND reset_password_token_expiry > now() AT TIME ZONE 'UTC'
RETURNING
    id,
    created,
    modified,
    deleted,
    first_name,
    last_name,
    access_Level,
    credit_balance,
    username,
    user_email_address,
    user_avatar_url,
    user_zone_info,
    user_locale,
    is_locked,
    last_login,
    reset_password_token,
    reset_password_token_expiry
`

type UpdateAccountResetPasswordByTokenParams struct {
	ResetPasswordToken pgtype.Text `db:"reset_password_token" json:"resetPasswordToken"`
	UserPassword       pgtype.Text `db:"user_password" json:"userPassword"`
}

type UpdateAccountResetPasswordByTokenRow struct {
	ID                       pgtype.UUID        `db:"id" json:"id"`
	Created                  pgtype.Timestamptz `db:"created" json:"created"`
	Modified                 pgtype.Timestamptz `db:"modified" json:"modified"`
	Deleted                  pgtype.Timestamptz `db:"deleted" json:"deleted"`
	FirstName                pgtype.Text        `db:"first_name" json:"firstName"`
	LastName                 pgtype.Text        `db:"last_name" json:"lastName"`
	AccessLevel              pgtype.Int4        `db:"access_level" json:"accessLevel"`
	CreditBalance            float64            `db:"credit_balance" json:"creditBalance"`
	Username                 string             `db:"username" json:"username"`
	UserEmailAddress         string             `db:"user_email_address" json:"userEmailAddress"`
	UserAvatarUrl            pgtype.Text        `db:"user_avatar_url" json:"userAvatarUrl"`
	UserZoneInfo             pgtype.Text        `db:"user_zone_info" json:"userZoneInfo"`
	UserLocale               pgtype.Text        `db:"user_locale" json:"userLocale"`
	IsLocked                 bool               `db:"is_locked" json:"isLocked"`
	LastLogin                pgtype.Timestamptz `db:"last_login" json:"lastLogin"`
	ResetPasswordToken       pgtype.Text        `db:"reset_password_token" json:"resetPasswordToken"`
	ResetPasswordTokenExpiry pgtype.Timestamptz `db:"reset_password_token_expiry" json:"resetPasswordTokenExpiry"`
}

func (q *Queries) UpdateAccountResetPasswordByToken(ctx context.Context, arg UpdateAccountResetPasswordByTokenParams) (UpdateAccountResetPasswordByTokenRow, error) {
	row := q.db.QueryRow(ctx, updateAccountResetPasswordByToken, arg.ResetPasswordToken, arg.UserPassword)
	var i UpdateAccountResetPasswordByTokenRow
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Modified,
		&i.Deleted,
		&i.FirstName,
		&i.LastName,
		&i.AccessLevel,
		&i.CreditBalance,
		&i.Username,
		&i.UserEmailAddress,
		&i.UserAvatarUrl,
		&i.UserZoneInfo,
		&i.UserLocale,
		&i.IsLocked,
		&i.LastLogin,
		&i.ResetPasswordToken,
		&i.ResetPasswordTokenExpiry,
	)
	return i, err
}

const updateAccountResetPasswordToken = `-- name: UpdateAccountResetPasswordToken :one
UPDATE account
SET
    modified = now() AT TIME ZONE 'UTC',
    reset_password_token = $2,
    reset_password_token_expiry = $3
WHERE id = $1
RETURNING
    id,
    created,
    modified,
    deleted,
    first_name,
    last_name,
    access_Level,
    credit_balance,
    username,
    user_email_address,
    user_avatar_url,
    user_zone_info,
    user_locale,
    is_locked,
    last_login,
    reset_password_token,
    reset_password_token_expiry
`

type UpdateAccountResetPasswordTokenParams struct {
	ID                       pgtype.UUID        `db:"id" json:"id"`
	ResetPasswordToken       pgtype.Text        `db:"reset_password_token" json:"resetPasswordToken"`
	ResetPasswordTokenExpiry pgtype.Timestamptz `db:"reset_password_token_expiry" json:"resetPasswordTokenExpiry"`
}

type UpdateAccountResetPasswordTokenRow struct {
	ID                       pgtype.UUID        `db:"id" json:"id"`
	Created                  pgtype.Timestamptz `db:"created" json:"created"`
	Modified                 pgtype.Timestamptz `db:"modified" json:"modified"`
	Deleted                  pgtype.Timestamptz `db:"deleted" json:"deleted"`
	FirstName                pgtype.Text        `db:"first_name" json:"firstName"`
	LastName                 pgtype.Text        `db:"last_name" json:"lastName"`
	AccessLevel              pgtype.Int4        `db:"access_level" json:"accessLevel"`
	CreditBalance            float64            `db:"credit_balance" json:"creditBalance"`
	Username                 string             `db:"username" json:"username"`
	UserEmailAddress         string             `db:"user_email_address" json:"userEmailAddress"`
	UserAvatarUrl            pgtype.Text        `db:"user_avatar_url" json:"userAvatarUrl"`
	UserZoneInfo             pgtype.Text        `db:"user_zone_info" json:"userZoneInfo"`
	UserLocale               pgtype.Text        `db:"user_locale" json:"userLocale"`
	IsLocked                 bool               `db:"is_locked" json:"isLocked"`
	LastLogin                pgtype.Timestamptz `db:"last_login" json:"lastLogin"`
	ResetPasswordToken       pgtype.Text        `db:"reset_password_token" json:"resetPasswordToken"`
	ResetPasswordTokenExpiry pgtype.Timestamptz `db:"reset_password_token_expiry" json:"resetPasswordTokenExpiry"`
}

func (q *Queries) UpdateAccountResetPasswordToken(ctx context.Context, arg UpdateAccountResetPasswordTokenParams) (UpdateAccountResetPasswordTokenRow, error) {
	row := q.db.QueryRow(ctx, updateAccountResetPasswordToken, arg.ID, arg.ResetPasswordToken, arg.ResetPasswordTokenExpiry)
	var i UpdateAccountResetPasswordTokenRow
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Modified,
		&i.Deleted,
		&i.FirstName,
		&i.LastName,
		&i.AccessLevel,
		&i.CreditBalance,
		&i.Username,
		&i.UserEmailAddress,
		&i.UserAvatarUrl,
		&i.UserZoneInfo,
		&i.UserLocale,
		&i.IsLocked,
		&i.LastLogin,
		&i.ResetPasswordToken,
		&i.ResetPasswordTokenExpiry,
	)
	return i, err
}

const updateSystemProfile = `-- name: UpdateSystemProfile :one
UPDATE account
SET
    modified = now() AT TIME ZONE 'UTC',
    user_password = $2
WHERE id = $1
RETURNING
    id,
    created,
    modified,
    deleted,
    first_name,
    last_name,
    access_Level,
    credit_balance,
    username,
    user_email_address,
    user_avatar_url,
    user_zone_info,
    user_locale,
    is_locked,
    last_login,
    reset_password_token,
    reset_password_token_expiry
`

type UpdateSystemProfileParams struct {
	ID           pgtype.UUID `db:"id" json:"id"`
	UserPassword pgtype.Text `db:"user_password" json:"userPassword"`
}

type UpdateSystemProfileRow struct {
	ID                       pgtype.UUID        `db:"id" json:"id"`
	Created                  pgtype.Timestamptz `db:"created" json:"created"`
	Modified                 pgtype.Timestamptz `db:"modified" json:"modified"`
	Deleted                  pgtype.Timestamptz `db:"deleted" json:"deleted"`
	FirstName                pgtype.Text        `db:"first_name" json:"firstName"`
	LastName                 pgtype.Text        `db:"last_name" json:"lastName"`
	AccessLevel              pgtype.Int4        `db:"access_level" json:"accessLevel"`
	CreditBalance            float64            `db:"credit_balance" json:"creditBalance"`
	Username                 string             `db:"username" json:"username"`
	UserEmailAddress         string             `db:"user_email_address" json:"userEmailAddress"`
	UserAvatarUrl            pgtype.Text        `db:"user_avatar_url" json:"userAvatarUrl"`
	UserZoneInfo             pgtype.Text        `db:"user_zone_info" json:"userZoneInfo"`
	UserLocale               pgtype.Text        `db:"user_locale" json:"userLocale"`
	IsLocked                 bool               `db:"is_locked" json:"isLocked"`
	LastLogin                pgtype.Timestamptz `db:"last_login" json:"lastLogin"`
	ResetPasswordToken       pgtype.Text        `db:"reset_password_token" json:"resetPasswordToken"`
	ResetPasswordTokenExpiry pgtype.Timestamptz `db:"reset_password_token_expiry" json:"resetPasswordTokenExpiry"`
}

func (q *Queries) UpdateSystemProfile(ctx context.Context, arg UpdateSystemProfileParams) (UpdateSystemProfileRow, error) {
	row := q.db.QueryRow(ctx, updateSystemProfile, arg.ID, arg.UserPassword)
	var i UpdateSystemProfileRow
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Modified,
		&i.Deleted,
		&i.FirstName,
		&i.LastName,
		&i.AccessLevel,
		&i.CreditBalance,
		&i.Username,
		&i.UserEmailAddress,
		&i.UserAvatarUrl,
		&i.UserZoneInfo,
		&i.UserLocale,
		&i.IsLocked,
		&i.LastLogin,
		&i.ResetPasswordToken,
		&i.ResetPasswordTokenExpiry,
	)
	return i, err
}
