// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: location.sql

package db_gen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countLocations = `-- name: CountLocations :one
SELECT
    COUNT(id)
FROM location
WHERE deleted > now() AT TIME ZONE 'UTC'
`

func (q *Queries) CountLocations(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countLocations)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createLocation = `-- name: CreateLocation :one
INSERT INTO location (
    id,
    created,
    modified,
    deleted,
    name,
    code,
    ordering,
    is_active
) VALUES (
             uuid_generate_v4(),
             now() AT TIME ZONE 'UTC',
             now() AT TIME ZONE 'UTC',
             'infinity'::timestamp AT TIME ZONE 'UTC',
             $1, $2, $3, $4
         )
RETURNING id, created, modified, deleted, name, code, ordering, is_active
`

type CreateLocationParams struct {
	Name     string `db:"name" json:"name"`
	Code     string `db:"code" json:"code"`
	Ordering int32  `db:"ordering" json:"ordering"`
	IsActive bool   `db:"is_active" json:"isActive"`
}

func (q *Queries) CreateLocation(ctx context.Context, arg CreateLocationParams) (Location, error) {
	row := q.db.QueryRow(ctx, createLocation,
		arg.Name,
		arg.Code,
		arg.Ordering,
		arg.IsActive,
	)
	var i Location
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Modified,
		&i.Deleted,
		&i.Name,
		&i.Code,
		&i.Ordering,
		&i.IsActive,
	)
	return i, err
}

const createLocationAndReturnId = `-- name: CreateLocationAndReturnId :one
INSERT INTO location (
    id,
    created,
    modified,
    deleted,
    name,
    code,
    ordering,
    is_active
) VALUES (
             uuid_generate_v4(),
             now() AT TIME ZONE 'UTC',
             now() AT TIME ZONE 'UTC',
             'infinity'::timestamp AT TIME ZONE 'UTC',
             $1, $2, $3, $4
         )
RETURNING id
`

type CreateLocationAndReturnIdParams struct {
	Name     string `db:"name" json:"name"`
	Code     string `db:"code" json:"code"`
	Ordering int32  `db:"ordering" json:"ordering"`
	IsActive bool   `db:"is_active" json:"isActive"`
}

func (q *Queries) CreateLocationAndReturnId(ctx context.Context, arg CreateLocationAndReturnIdParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, createLocationAndReturnId,
		arg.Name,
		arg.Code,
		arg.Ordering,
		arg.IsActive,
	)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const deleteLocation = `-- name: DeleteLocation :exec
UPDATE location
SET
    deleted = now() AT TIME ZONE 'UTC'
WHERE id = $1
`

func (q *Queries) DeleteLocation(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteLocation, id)
	return err
}

const getLocation = `-- name: GetLocation :one
SELECT id, created, modified, deleted, name, code, ordering, is_active FROM location
WHERE id = $1
  AND deleted > now() AT TIME ZONE 'UTC'
LIMIT 1
`

func (q *Queries) GetLocation(ctx context.Context, id pgtype.UUID) (Location, error) {
	row := q.db.QueryRow(ctx, getLocation, id)
	var i Location
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Modified,
		&i.Deleted,
		&i.Name,
		&i.Code,
		&i.Ordering,
		&i.IsActive,
	)
	return i, err
}

const getLocationByCode = `-- name: GetLocationByCode :one
SELECT id, created, modified, deleted, name, code, ordering, is_active FROM location
WHERE code = $1
  AND deleted > now() AT TIME ZONE 'UTC'
  AND is_active = TRUE
LIMIT 1
`

func (q *Queries) GetLocationByCode(ctx context.Context, code string) (Location, error) {
	row := q.db.QueryRow(ctx, getLocationByCode, code)
	var i Location
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Modified,
		&i.Deleted,
		&i.Name,
		&i.Code,
		&i.Ordering,
		&i.IsActive,
	)
	return i, err
}

const getLocationById = `-- name: GetLocationById :one
SELECT id, created, modified, deleted, name, code, ordering, is_active FROM location
WHERE id = $1
  AND deleted > now() AT TIME ZONE 'UTC'
LIMIT 1
`

func (q *Queries) GetLocationById(ctx context.Context, id pgtype.UUID) (Location, error) {
	row := q.db.QueryRow(ctx, getLocationById, id)
	var i Location
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Modified,
		&i.Deleted,
		&i.Name,
		&i.Code,
		&i.Ordering,
		&i.IsActive,
	)
	return i, err
}

const getLocationByName = `-- name: GetLocationByName :one
SELECT id, created, modified, deleted, name, code, ordering, is_active FROM location
WHERE name = $1
  AND deleted > now() AT TIME ZONE 'UTC'
  AND is_active = TRUE
LIMIT 1
`

func (q *Queries) GetLocationByName(ctx context.Context, name string) (Location, error) {
	row := q.db.QueryRow(ctx, getLocationByName, name)
	var i Location
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Modified,
		&i.Deleted,
		&i.Name,
		&i.Code,
		&i.Ordering,
		&i.IsActive,
	)
	return i, err
}

const listEndLocationsByProductTypeSlug = `-- name: ListEndLocationsByProductTypeSlug :many
SELECT DISTINCT location.id, location.created, location.modified, location.deleted, location.name, location.code, location.ordering, location.is_active, station.latitude, station.longitude FROM service_route
  INNER JOIN product_type ON product_type.slug=$1
  INNER JOIN service ON service_route.service_id=service.id AND product_type.id=service.product_type_id
  INNER JOIN station ON service_route.end_station_id=station.id
  INNER JOIN location ON station.location_id=location.id
AND location.deleted > now() AT TIME ZONE 'UTC'
ORDER BY station.latitude, station.longitude
`

type ListEndLocationsByProductTypeSlugRow struct {
	ID        pgtype.UUID        `db:"id" json:"id"`
	Created   pgtype.Timestamptz `db:"created" json:"created"`
	Modified  pgtype.Timestamptz `db:"modified" json:"modified"`
	Deleted   pgtype.Timestamptz `db:"deleted" json:"deleted"`
	Name      string             `db:"name" json:"name"`
	Code      string             `db:"code" json:"code"`
	Ordering  int32              `db:"ordering" json:"ordering"`
	IsActive  bool               `db:"is_active" json:"isActive"`
	Latitude  string             `db:"latitude" json:"latitude"`
	Longitude string             `db:"longitude" json:"longitude"`
}

func (q *Queries) ListEndLocationsByProductTypeSlug(ctx context.Context, slug string) ([]ListEndLocationsByProductTypeSlugRow, error) {
	rows, err := q.db.Query(ctx, listEndLocationsByProductTypeSlug, slug)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListEndLocationsByProductTypeSlugRow
	for rows.Next() {
		var i ListEndLocationsByProductTypeSlugRow
		if err := rows.Scan(
			&i.ID,
			&i.Created,
			&i.Modified,
			&i.Deleted,
			&i.Name,
			&i.Code,
			&i.Ordering,
			&i.IsActive,
			&i.Latitude,
			&i.Longitude,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLocationsAsc = `-- name: ListLocationsAsc :many
SELECT id, created, modified, deleted, name, code, ordering, is_active FROM location
WHERE deleted > now() AT TIME ZONE 'UTC'
ORDER BY $1::text
OFFSET ($2::int - 1) * $3::int
    FETCH NEXT $3 ROWS ONLY
`

type ListLocationsAscParams struct {
	SortBy            string `db:"sort_by" json:"sortBy"`
	RequestedPage     int32  `db:"requested_page" json:"requestedPage"`
	RequestedPageSize int32  `db:"requested_page_size" json:"requestedPageSize"`
}

func (q *Queries) ListLocationsAsc(ctx context.Context, arg ListLocationsAscParams) ([]Location, error) {
	rows, err := q.db.Query(ctx, listLocationsAsc, arg.SortBy, arg.RequestedPage, arg.RequestedPageSize)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Location
	for rows.Next() {
		var i Location
		if err := rows.Scan(
			&i.ID,
			&i.Created,
			&i.Modified,
			&i.Deleted,
			&i.Name,
			&i.Code,
			&i.Ordering,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLocationsDesc = `-- name: ListLocationsDesc :many
SELECT id, created, modified, deleted, name, code, ordering, is_active FROM location
WHERE deleted > now() AT TIME ZONE 'UTC'
ORDER BY $1::text DESC
OFFSET ($2::int - 1) * $3::int
    FETCH NEXT $3 ROWS ONLY
`

type ListLocationsDescParams struct {
	SortBy            string `db:"sort_by" json:"sortBy"`
	RequestedPage     int32  `db:"requested_page" json:"requestedPage"`
	RequestedPageSize int32  `db:"requested_page_size" json:"requestedPageSize"`
}

func (q *Queries) ListLocationsDesc(ctx context.Context, arg ListLocationsDescParams) ([]Location, error) {
	rows, err := q.db.Query(ctx, listLocationsDesc, arg.SortBy, arg.RequestedPage, arg.RequestedPageSize)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Location
	for rows.Next() {
		var i Location
		if err := rows.Scan(
			&i.ID,
			&i.Created,
			&i.Modified,
			&i.Deleted,
			&i.Name,
			&i.Code,
			&i.Ordering,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPairedEndLocationsByStartLocationAndProductTypeSlug = `-- name: ListPairedEndLocationsByStartLocationAndProductTypeSlug :many
SELECT DISTINCT location.id, location.created, location.modified, location.deleted, location.name, location.code, location.ordering, location.is_active, end_station.latitude, end_station.longitude
FROM service_route
         INNER JOIN service ON service_route.service_id=service.id
         INNER JOIN product_type ON service.product_type_id=product_type.id
         INNER JOIN station start_station ON service_route.start_station_id=start_station.id
         INNER JOIN station end_station ON service_route.end_station_id=end_station.id
         INNER JOIN location ON location.id=end_station.location_id
WHERE product_type.slug=$1::TEXT
  AND service.deleted > now() AT TIME ZONE 'UTC'
  AND start_station.location_id=$2::UUID
ORDER BY end_station.latitude, end_station.longitude
`

type ListPairedEndLocationsByStartLocationAndProductTypeSlugParams struct {
	Slug            string      `db:"slug" json:"slug"`
	StartLocationID pgtype.UUID `db:"start_location_id" json:"startLocationId"`
}

type ListPairedEndLocationsByStartLocationAndProductTypeSlugRow struct {
	ID        pgtype.UUID        `db:"id" json:"id"`
	Created   pgtype.Timestamptz `db:"created" json:"created"`
	Modified  pgtype.Timestamptz `db:"modified" json:"modified"`
	Deleted   pgtype.Timestamptz `db:"deleted" json:"deleted"`
	Name      string             `db:"name" json:"name"`
	Code      string             `db:"code" json:"code"`
	Ordering  int32              `db:"ordering" json:"ordering"`
	IsActive  bool               `db:"is_active" json:"isActive"`
	Latitude  string             `db:"latitude" json:"latitude"`
	Longitude string             `db:"longitude" json:"longitude"`
}

func (q *Queries) ListPairedEndLocationsByStartLocationAndProductTypeSlug(ctx context.Context, arg ListPairedEndLocationsByStartLocationAndProductTypeSlugParams) ([]ListPairedEndLocationsByStartLocationAndProductTypeSlugRow, error) {
	rows, err := q.db.Query(ctx, listPairedEndLocationsByStartLocationAndProductTypeSlug, arg.Slug, arg.StartLocationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPairedEndLocationsByStartLocationAndProductTypeSlugRow
	for rows.Next() {
		var i ListPairedEndLocationsByStartLocationAndProductTypeSlugRow
		if err := rows.Scan(
			&i.ID,
			&i.Created,
			&i.Modified,
			&i.Deleted,
			&i.Name,
			&i.Code,
			&i.Ordering,
			&i.IsActive,
			&i.Latitude,
			&i.Longitude,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPairedStartLocationsByEndLocationAndProductTypeSlug = `-- name: ListPairedStartLocationsByEndLocationAndProductTypeSlug :many
SELECT DISTINCT location.id, location.created, location.modified, location.deleted, location.name, location.code, location.ordering, location.is_active, start_station.latitude, start_station.longitude
FROM service_route
         INNER JOIN service ON service_route.service_id=service.id
         INNER JOIN product_type ON service.product_type_id=product_type.id
         INNER JOIN station start_station ON service_route.start_station_id=start_station.id
         INNER JOIN station end_station ON service_route.end_station_id=end_station.id
         INNER JOIN location ON location.id=start_station.location_id
WHERE product_type.slug=$1::TEXT
  AND service.deleted > now() AT TIME ZONE 'UTC'
  AND end_station.location_id=$2::UUID
ORDER BY start_station.latitude, start_station.longitude
`

type ListPairedStartLocationsByEndLocationAndProductTypeSlugParams struct {
	Slug          string      `db:"slug" json:"slug"`
	EndLocationID pgtype.UUID `db:"end_location_id" json:"endLocationId"`
}

type ListPairedStartLocationsByEndLocationAndProductTypeSlugRow struct {
	ID        pgtype.UUID        `db:"id" json:"id"`
	Created   pgtype.Timestamptz `db:"created" json:"created"`
	Modified  pgtype.Timestamptz `db:"modified" json:"modified"`
	Deleted   pgtype.Timestamptz `db:"deleted" json:"deleted"`
	Name      string             `db:"name" json:"name"`
	Code      string             `db:"code" json:"code"`
	Ordering  int32              `db:"ordering" json:"ordering"`
	IsActive  bool               `db:"is_active" json:"isActive"`
	Latitude  string             `db:"latitude" json:"latitude"`
	Longitude string             `db:"longitude" json:"longitude"`
}

func (q *Queries) ListPairedStartLocationsByEndLocationAndProductTypeSlug(ctx context.Context, arg ListPairedStartLocationsByEndLocationAndProductTypeSlugParams) ([]ListPairedStartLocationsByEndLocationAndProductTypeSlugRow, error) {
	rows, err := q.db.Query(ctx, listPairedStartLocationsByEndLocationAndProductTypeSlug, arg.Slug, arg.EndLocationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPairedStartLocationsByEndLocationAndProductTypeSlugRow
	for rows.Next() {
		var i ListPairedStartLocationsByEndLocationAndProductTypeSlugRow
		if err := rows.Scan(
			&i.ID,
			&i.Created,
			&i.Modified,
			&i.Deleted,
			&i.Name,
			&i.Code,
			&i.Ordering,
			&i.IsActive,
			&i.Latitude,
			&i.Longitude,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStartLocationsByProductTypeSlug = `-- name: ListStartLocationsByProductTypeSlug :many
SELECT DISTINCT location.id, location.created, location.modified, location.deleted, location.name, location.code, location.ordering, location.is_active, station.latitude, station.longitude FROM service_route
  INNER JOIN product_type ON product_type.slug=$1
  INNER JOIN service ON service_route.service_id=service.id AND product_type.id=service.product_type_id
  INNER JOIN station ON service_route.start_station_id=station.id
  INNER JOIN location ON station.location_id=location.id
AND location.deleted > now() AT TIME ZONE 'UTC'
ORDER BY station.latitude, station.longitude
`

type ListStartLocationsByProductTypeSlugRow struct {
	ID        pgtype.UUID        `db:"id" json:"id"`
	Created   pgtype.Timestamptz `db:"created" json:"created"`
	Modified  pgtype.Timestamptz `db:"modified" json:"modified"`
	Deleted   pgtype.Timestamptz `db:"deleted" json:"deleted"`
	Name      string             `db:"name" json:"name"`
	Code      string             `db:"code" json:"code"`
	Ordering  int32              `db:"ordering" json:"ordering"`
	IsActive  bool               `db:"is_active" json:"isActive"`
	Latitude  string             `db:"latitude" json:"latitude"`
	Longitude string             `db:"longitude" json:"longitude"`
}

func (q *Queries) ListStartLocationsByProductTypeSlug(ctx context.Context, slug string) ([]ListStartLocationsByProductTypeSlugRow, error) {
	rows, err := q.db.Query(ctx, listStartLocationsByProductTypeSlug, slug)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListStartLocationsByProductTypeSlugRow
	for rows.Next() {
		var i ListStartLocationsByProductTypeSlugRow
		if err := rows.Scan(
			&i.ID,
			&i.Created,
			&i.Modified,
			&i.Deleted,
			&i.Name,
			&i.Code,
			&i.Ordering,
			&i.IsActive,
			&i.Latitude,
			&i.Longitude,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateLocation = `-- name: UpdateLocation :one
UPDATE location
SET
    modified = now() AT TIME ZONE 'UTC',
    name = $2,
    code = $3,
    ordering = $4,
    is_active = $5
WHERE id = $1
RETURNING id, created, modified, deleted, name, code, ordering, is_active
`

type UpdateLocationParams struct {
	ID       pgtype.UUID `db:"id" json:"id"`
	Name     string      `db:"name" json:"name"`
	Code     string      `db:"code" json:"code"`
	Ordering int32       `db:"ordering" json:"ordering"`
	IsActive bool        `db:"is_active" json:"isActive"`
}

func (q *Queries) UpdateLocation(ctx context.Context, arg UpdateLocationParams) (Location, error) {
	row := q.db.QueryRow(ctx, updateLocation,
		arg.ID,
		arg.Name,
		arg.Code,
		arg.Ordering,
		arg.IsActive,
	)
	var i Location
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Modified,
		&i.Deleted,
		&i.Name,
		&i.Code,
		&i.Ordering,
		&i.IsActive,
	)
	return i, err
}
