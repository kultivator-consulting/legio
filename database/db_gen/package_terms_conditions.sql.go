// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: package_terms_conditions.sql

package db_gen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countPackageTermsConditionsByPackageId = `-- name: CountPackageTermsConditionsByPackageId :one
SELECT
    COUNT(id)
FROM package_terms_conditions
WHERE package_id = $1
`

func (q *Queries) CountPackageTermsConditionsByPackageId(ctx context.Context, packageID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countPackageTermsConditionsByPackageId, packageID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createPackageTermsConditions = `-- name: CreatePackageTermsConditions :one
INSERT INTO package_terms_conditions (
    id,
    created,
    modified,
    package_id,
    general_terms,
    luggage_notes,
    additional_notes
) VALUES (
             uuid_generate_v4(),
             now() AT TIME ZONE 'UTC',
             now() AT TIME ZONE 'UTC',
             $1, $2, $3, $4
         )
RETURNING id, created, modified, package_id, general_terms, luggage_notes, additional_notes
`

type CreatePackageTermsConditionsParams struct {
	PackageID       pgtype.UUID `db:"package_id" json:"packageId"`
	GeneralTerms    pgtype.Text `db:"general_terms" json:"generalTerms"`
	LuggageNotes    pgtype.Text `db:"luggage_notes" json:"luggageNotes"`
	AdditionalNotes pgtype.Text `db:"additional_notes" json:"additionalNotes"`
}

func (q *Queries) CreatePackageTermsConditions(ctx context.Context, arg CreatePackageTermsConditionsParams) (PackageTermsConditions, error) {
	row := q.db.QueryRow(ctx, createPackageTermsConditions,
		arg.PackageID,
		arg.GeneralTerms,
		arg.LuggageNotes,
		arg.AdditionalNotes,
	)
	var i PackageTermsConditions
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Modified,
		&i.PackageID,
		&i.GeneralTerms,
		&i.LuggageNotes,
		&i.AdditionalNotes,
	)
	return i, err
}

const deletePackageTermsConditions = `-- name: DeletePackageTermsConditions :exec
DELETE FROM package_terms_conditions
WHERE id = $1
`

func (q *Queries) DeletePackageTermsConditions(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deletePackageTermsConditions, id)
	return err
}

const deletePackageTermsConditionsByPackageId = `-- name: DeletePackageTermsConditionsByPackageId :exec
DELETE FROM package_terms_conditions
WHERE package_id = $1
`

func (q *Queries) DeletePackageTermsConditionsByPackageId(ctx context.Context, packageID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deletePackageTermsConditionsByPackageId, packageID)
	return err
}

const getPackageTermsConditionsById = `-- name: GetPackageTermsConditionsById :one
SELECT id, created, modified, package_id, general_terms, luggage_notes, additional_notes FROM package_terms_conditions
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetPackageTermsConditionsById(ctx context.Context, id pgtype.UUID) (PackageTermsConditions, error) {
	row := q.db.QueryRow(ctx, getPackageTermsConditionsById, id)
	var i PackageTermsConditions
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Modified,
		&i.PackageID,
		&i.GeneralTerms,
		&i.LuggageNotes,
		&i.AdditionalNotes,
	)
	return i, err
}

const getPackageTermsConditionsByPackageId = `-- name: GetPackageTermsConditionsByPackageId :many
SELECT id, created, modified, package_id, general_terms, luggage_notes, additional_notes FROM package_terms_conditions
WHERE package_id = $1
`

func (q *Queries) GetPackageTermsConditionsByPackageId(ctx context.Context, packageID pgtype.UUID) ([]PackageTermsConditions, error) {
	rows, err := q.db.Query(ctx, getPackageTermsConditionsByPackageId, packageID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PackageTermsConditions
	for rows.Next() {
		var i PackageTermsConditions
		if err := rows.Scan(
			&i.ID,
			&i.Created,
			&i.Modified,
			&i.PackageID,
			&i.GeneralTerms,
			&i.LuggageNotes,
			&i.AdditionalNotes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPackageTermsConditionsByPackageIdAsc = `-- name: ListPackageTermsConditionsByPackageIdAsc :many
SELECT id, created, modified, package_id, general_terms, luggage_notes, additional_notes FROM package_terms_conditions
WHERE package_id = $1
ORDER BY $2::text
OFFSET ($3::int - 1) * $4::int
    FETCH NEXT $4 ROWS ONLY
`

type ListPackageTermsConditionsByPackageIdAscParams struct {
	PackageID         pgtype.UUID `db:"package_id" json:"packageId"`
	SortBy            string      `db:"sort_by" json:"sortBy"`
	RequestedPage     int32       `db:"requested_page" json:"requestedPage"`
	RequestedPageSize int32       `db:"requested_page_size" json:"requestedPageSize"`
}

func (q *Queries) ListPackageTermsConditionsByPackageIdAsc(ctx context.Context, arg ListPackageTermsConditionsByPackageIdAscParams) ([]PackageTermsConditions, error) {
	rows, err := q.db.Query(ctx, listPackageTermsConditionsByPackageIdAsc,
		arg.PackageID,
		arg.SortBy,
		arg.RequestedPage,
		arg.RequestedPageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PackageTermsConditions
	for rows.Next() {
		var i PackageTermsConditions
		if err := rows.Scan(
			&i.ID,
			&i.Created,
			&i.Modified,
			&i.PackageID,
			&i.GeneralTerms,
			&i.LuggageNotes,
			&i.AdditionalNotes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPackageTermsConditionsByPackageIdDesc = `-- name: ListPackageTermsConditionsByPackageIdDesc :many
SELECT id, created, modified, package_id, general_terms, luggage_notes, additional_notes FROM package_terms_conditions
WHERE package_id = $1
ORDER BY $2::text DESC
OFFSET ($3::int - 1) * $4::int
    FETCH NEXT $4 ROWS ONLY
`

type ListPackageTermsConditionsByPackageIdDescParams struct {
	PackageID         pgtype.UUID `db:"package_id" json:"packageId"`
	SortBy            string      `db:"sort_by" json:"sortBy"`
	RequestedPage     int32       `db:"requested_page" json:"requestedPage"`
	RequestedPageSize int32       `db:"requested_page_size" json:"requestedPageSize"`
}

func (q *Queries) ListPackageTermsConditionsByPackageIdDesc(ctx context.Context, arg ListPackageTermsConditionsByPackageIdDescParams) ([]PackageTermsConditions, error) {
	rows, err := q.db.Query(ctx, listPackageTermsConditionsByPackageIdDesc,
		arg.PackageID,
		arg.SortBy,
		arg.RequestedPage,
		arg.RequestedPageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PackageTermsConditions
	for rows.Next() {
		var i PackageTermsConditions
		if err := rows.Scan(
			&i.ID,
			&i.Created,
			&i.Modified,
			&i.PackageID,
			&i.GeneralTerms,
			&i.LuggageNotes,
			&i.AdditionalNotes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePackageTermsConditions = `-- name: UpdatePackageTermsConditions :one
UPDATE package_terms_conditions
SET
    modified = now() AT TIME ZONE 'UTC',
    package_id = $2,
    general_terms = $3,
    luggage_notes = $4,
    additional_notes = $5
WHERE id = $1
RETURNING id, created, modified, package_id, general_terms, luggage_notes, additional_notes
`

type UpdatePackageTermsConditionsParams struct {
	ID              pgtype.UUID `db:"id" json:"id"`
	PackageID       pgtype.UUID `db:"package_id" json:"packageId"`
	GeneralTerms    pgtype.Text `db:"general_terms" json:"generalTerms"`
	LuggageNotes    pgtype.Text `db:"luggage_notes" json:"luggageNotes"`
	AdditionalNotes pgtype.Text `db:"additional_notes" json:"additionalNotes"`
}

func (q *Queries) UpdatePackageTermsConditions(ctx context.Context, arg UpdatePackageTermsConditionsParams) (PackageTermsConditions, error) {
	row := q.db.QueryRow(ctx, updatePackageTermsConditions,
		arg.ID,
		arg.PackageID,
		arg.GeneralTerms,
		arg.LuggageNotes,
		arg.AdditionalNotes,
	)
	var i PackageTermsConditions
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Modified,
		&i.PackageID,
		&i.GeneralTerms,
		&i.LuggageNotes,
		&i.AdditionalNotes,
	)
	return i, err
}
