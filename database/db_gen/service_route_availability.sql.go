// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: service_route_availability.sql

package db_gen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countServiceRouteAvailabilitiesByServiceIdAndDateRange = `-- name: CountServiceRouteAvailabilitiesByServiceIdAndDateRange :one
SELECT
    COUNT(id)
FROM service_route_availability
WHERE service_route_id = $1 AND start_date <= $2 AND end_date >= $3
`

type CountServiceRouteAvailabilitiesByServiceIdAndDateRangeParams struct {
	ServiceRouteID pgtype.UUID        `db:"service_route_id" json:"serviceRouteId"`
	StartDate      pgtype.Timestamptz `db:"start_date" json:"startDate"`
	EndDate        pgtype.Timestamptz `db:"end_date" json:"endDate"`
}

func (q *Queries) CountServiceRouteAvailabilitiesByServiceIdAndDateRange(ctx context.Context, arg CountServiceRouteAvailabilitiesByServiceIdAndDateRangeParams) (int64, error) {
	row := q.db.QueryRow(ctx, countServiceRouteAvailabilitiesByServiceIdAndDateRange, arg.ServiceRouteID, arg.StartDate, arg.EndDate)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countServiceRouteAvailabilitiesByServiceRouteId = `-- name: CountServiceRouteAvailabilitiesByServiceRouteId :one
SELECT
    COUNT(id)
FROM service_route_availability
WHERE service_route_id = $1
`

func (q *Queries) CountServiceRouteAvailabilitiesByServiceRouteId(ctx context.Context, serviceRouteID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countServiceRouteAvailabilitiesByServiceRouteId, serviceRouteID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createServiceRouteAvailability = `-- name: CreateServiceRouteAvailability :one
INSERT INTO service_route_availability (
    id,
    created,
    modified,
    service_route_id,
    departure_time,
    arrival_time,
    frequency,
    start_date,
    end_date,
    excluded_dates,
    sold_out_dates,
    ci_time_id,
    notes,
    is_active
) VALUES (
             uuid_generate_v4(),
             now() AT TIME ZONE 'UTC',
             now() AT TIME ZONE 'UTC',
             $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
         )
RETURNING id, created, modified, service_route_id, departure_time, arrival_time, frequency, start_date, end_date, excluded_dates, sold_out_dates, ci_time_id, notes, is_active
`

type CreateServiceRouteAvailabilityParams struct {
	ServiceRouteID pgtype.UUID          `db:"service_route_id" json:"serviceRouteId"`
	DepartureTime  pgtype.Timestamptz   `db:"departure_time" json:"departureTime"`
	ArrivalTime    pgtype.Timestamptz   `db:"arrival_time" json:"arrivalTime"`
	Frequency      string               `db:"frequency" json:"frequency"`
	StartDate      pgtype.Timestamptz   `db:"start_date" json:"startDate"`
	EndDate        pgtype.Timestamptz   `db:"end_date" json:"endDate"`
	ExcludedDates  []pgtype.Timestamptz `db:"excluded_dates" json:"excludedDates"`
	SoldOutDates   []pgtype.Timestamptz `db:"sold_out_dates" json:"soldOutDates"`
	CiTimeID       pgtype.Text          `db:"ci_time_id" json:"ciTimeId"`
	Notes          pgtype.Text          `db:"notes" json:"notes"`
	IsActive       bool                 `db:"is_active" json:"isActive"`
}

func (q *Queries) CreateServiceRouteAvailability(ctx context.Context, arg CreateServiceRouteAvailabilityParams) (ServiceRouteAvailability, error) {
	row := q.db.QueryRow(ctx, createServiceRouteAvailability,
		arg.ServiceRouteID,
		arg.DepartureTime,
		arg.ArrivalTime,
		arg.Frequency,
		arg.StartDate,
		arg.EndDate,
		arg.ExcludedDates,
		arg.SoldOutDates,
		arg.CiTimeID,
		arg.Notes,
		arg.IsActive,
	)
	var i ServiceRouteAvailability
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Modified,
		&i.ServiceRouteID,
		&i.DepartureTime,
		&i.ArrivalTime,
		&i.Frequency,
		&i.StartDate,
		&i.EndDate,
		&i.ExcludedDates,
		&i.SoldOutDates,
		&i.CiTimeID,
		&i.Notes,
		&i.IsActive,
	)
	return i, err
}

const deleteServiceRouteAvailability = `-- name: DeleteServiceRouteAvailability :exec
DELETE FROM service_route_availability
WHERE id = $1
`

func (q *Queries) DeleteServiceRouteAvailability(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteServiceRouteAvailability, id)
	return err
}

const deleteServiceRouteAvailabilityByServiceRouteId = `-- name: DeleteServiceRouteAvailabilityByServiceRouteId :exec
DELETE FROM service_route_availability
WHERE service_route_id = $1
`

func (q *Queries) DeleteServiceRouteAvailabilityByServiceRouteId(ctx context.Context, serviceRouteID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteServiceRouteAvailabilityByServiceRouteId, serviceRouteID)
	return err
}

const getServiceRouteAvailabilityByCiTimeId = `-- name: GetServiceRouteAvailabilityByCiTimeId :one
SELECT id, created, modified, service_route_id, departure_time, arrival_time, frequency, start_date, end_date, excluded_dates, sold_out_dates, ci_time_id, notes, is_active FROM service_route_availability
WHERE ci_time_id = $1
LIMIT 1
`

func (q *Queries) GetServiceRouteAvailabilityByCiTimeId(ctx context.Context, ciTimeID pgtype.Text) (ServiceRouteAvailability, error) {
	row := q.db.QueryRow(ctx, getServiceRouteAvailabilityByCiTimeId, ciTimeID)
	var i ServiceRouteAvailability
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Modified,
		&i.ServiceRouteID,
		&i.DepartureTime,
		&i.ArrivalTime,
		&i.Frequency,
		&i.StartDate,
		&i.EndDate,
		&i.ExcludedDates,
		&i.SoldOutDates,
		&i.CiTimeID,
		&i.Notes,
		&i.IsActive,
	)
	return i, err
}

const getServiceRouteAvailabilityById = `-- name: GetServiceRouteAvailabilityById :one
SELECT id, created, modified, service_route_id, departure_time, arrival_time, frequency, start_date, end_date, excluded_dates, sold_out_dates, ci_time_id, notes, is_active FROM service_route_availability
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetServiceRouteAvailabilityById(ctx context.Context, id pgtype.UUID) (ServiceRouteAvailability, error) {
	row := q.db.QueryRow(ctx, getServiceRouteAvailabilityById, id)
	var i ServiceRouteAvailability
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Modified,
		&i.ServiceRouteID,
		&i.DepartureTime,
		&i.ArrivalTime,
		&i.Frequency,
		&i.StartDate,
		&i.EndDate,
		&i.ExcludedDates,
		&i.SoldOutDates,
		&i.CiTimeID,
		&i.Notes,
		&i.IsActive,
	)
	return i, err
}

const listServiceRouteAvailabilitiesByServiceIdAndDateRange = `-- name: ListServiceRouteAvailabilitiesByServiceIdAndDateRange :many
SELECT id, created, modified, service_route_id, departure_time, arrival_time, frequency, start_date, end_date, excluded_dates, sold_out_dates, ci_time_id, notes, is_active FROM service_route_availability
WHERE service_route_id = $1 AND start_date <= $2 AND end_date >= $3
`

type ListServiceRouteAvailabilitiesByServiceIdAndDateRangeParams struct {
	ServiceRouteID pgtype.UUID        `db:"service_route_id" json:"serviceRouteId"`
	StartDate      pgtype.Timestamptz `db:"start_date" json:"startDate"`
	EndDate        pgtype.Timestamptz `db:"end_date" json:"endDate"`
}

func (q *Queries) ListServiceRouteAvailabilitiesByServiceIdAndDateRange(ctx context.Context, arg ListServiceRouteAvailabilitiesByServiceIdAndDateRangeParams) ([]ServiceRouteAvailability, error) {
	rows, err := q.db.Query(ctx, listServiceRouteAvailabilitiesByServiceIdAndDateRange, arg.ServiceRouteID, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ServiceRouteAvailability
	for rows.Next() {
		var i ServiceRouteAvailability
		if err := rows.Scan(
			&i.ID,
			&i.Created,
			&i.Modified,
			&i.ServiceRouteID,
			&i.DepartureTime,
			&i.ArrivalTime,
			&i.Frequency,
			&i.StartDate,
			&i.EndDate,
			&i.ExcludedDates,
			&i.SoldOutDates,
			&i.CiTimeID,
			&i.Notes,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listServiceRouteAvailabilitiesByServiceRouteId = `-- name: ListServiceRouteAvailabilitiesByServiceRouteId :many
SELECT id, created, modified, service_route_id, departure_time, arrival_time, frequency, start_date, end_date, excluded_dates, sold_out_dates, ci_time_id, notes, is_active FROM service_route_availability
WHERE service_route_id = $1
`

func (q *Queries) ListServiceRouteAvailabilitiesByServiceRouteId(ctx context.Context, serviceRouteID pgtype.UUID) ([]ServiceRouteAvailability, error) {
	rows, err := q.db.Query(ctx, listServiceRouteAvailabilitiesByServiceRouteId, serviceRouteID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ServiceRouteAvailability
	for rows.Next() {
		var i ServiceRouteAvailability
		if err := rows.Scan(
			&i.ID,
			&i.Created,
			&i.Modified,
			&i.ServiceRouteID,
			&i.DepartureTime,
			&i.ArrivalTime,
			&i.Frequency,
			&i.StartDate,
			&i.EndDate,
			&i.ExcludedDates,
			&i.SoldOutDates,
			&i.CiTimeID,
			&i.Notes,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const serviceRouteAvailabilitiesSearch = `-- name: ServiceRouteAvailabilitiesSearch :many
SELECT service.name,
       service.sub_service_name,
       service.description,
       service.excluded_dates AS service_excluded_dates,
       service.sold_out_dates AS service_sold_out_dates,
       service_route.start_station_id,
       service_route.end_station_id,
       service_route.is_active,
       service_route.is_main_route,
       service_route.ic_route_id,
       service_route_availability.start_date,
       service_route_availability.end_date,
       service_route_availability.departure_time,
       service_route_availability.arrival_time,
       service_route_availability.frequency,
       service_route_availability.ci_time_id,
       service_route_availability.notes,
       service_route_pricing.price_type,
       service_route_pricing.adult_price,
       service_route_pricing.child_price,
       service_route_pricing.infant_price,
       service_route_pricing.excluded_dates AS service_route_pricing_excluded_dates,
       service_route_pricing.sold_out_dates AS service_route_pricing_sold_out_dates,
       fare_type.name AS fare_type_name,
       start_station.name AS start_station_name,
       start_station.address AS start_station_address,
       end_station.name AS end_station_name,
       end_station.address AS end_station_address
FROM service_route
    INNER JOIN service ON service_route.service_id=service.id
    INNER JOIN product_type ON service.product_type_id=product_type.id
    INNER JOIN service_route_availability ON service_route_availability.service_route_id=service_route.id
    INNER JOIN service_route_pricing ON service_route_pricing.service_route_availability_id=service_route_availability.id
    INNER JOIN fare_type ON service_route_pricing.fare_type_id=fare_type.id
    INNER JOIN station start_station ON service_route.start_station_id=start_station.id
    INNER JOIN station end_station ON service_route.end_station_id=end_station.id
WHERE product_type.slug=$1::TEXT
    AND service.deleted > now() AT TIME ZONE 'UTC'
    AND start_station.location_id=$2::UUID
    AND end_station.location_id=$3::UUID
    AND service_route_pricing.start_date<=$4::TIMESTAMP WITH TIME ZONE
    AND service_route_pricing.end_date>=$5::TIMESTAMP WITH TIME ZONE
    AND service_route_availability.start_date<=$4::TIMESTAMP WITH TIME ZONE
    AND service_route_availability.end_date>=$5::TIMESTAMP WITH TIME ZONE
`

type ServiceRouteAvailabilitiesSearchParams struct {
	ProductTypeSlug string             `db:"product_type_slug" json:"productTypeSlug"`
	StartLocationID pgtype.UUID        `db:"start_location_id" json:"startLocationId"`
	EndLocationID   pgtype.UUID        `db:"end_location_id" json:"endLocationId"`
	SearchStartDate pgtype.Timestamptz `db:"search_start_date" json:"searchStartDate"`
	SearchEndDate   pgtype.Timestamptz `db:"search_end_date" json:"searchEndDate"`
}

type ServiceRouteAvailabilitiesSearchRow struct {
	Name                             string               `db:"name" json:"name"`
	SubServiceName                   pgtype.Text          `db:"sub_service_name" json:"subServiceName"`
	Description                      pgtype.Text          `db:"description" json:"description"`
	ServiceExcludedDates             []pgtype.Timestamptz `db:"service_excluded_dates" json:"serviceExcludedDates"`
	ServiceSoldOutDates              []pgtype.Timestamptz `db:"service_sold_out_dates" json:"serviceSoldOutDates"`
	StartStationID                   pgtype.UUID          `db:"start_station_id" json:"startStationId"`
	EndStationID                     pgtype.UUID          `db:"end_station_id" json:"endStationId"`
	IsActive                         bool                 `db:"is_active" json:"isActive"`
	IsMainRoute                      bool                 `db:"is_main_route" json:"isMainRoute"`
	IcRouteID                        pgtype.Text          `db:"ic_route_id" json:"icRouteId"`
	StartDate                        pgtype.Timestamptz   `db:"start_date" json:"startDate"`
	EndDate                          pgtype.Timestamptz   `db:"end_date" json:"endDate"`
	DepartureTime                    pgtype.Timestamptz   `db:"departure_time" json:"departureTime"`
	ArrivalTime                      pgtype.Timestamptz   `db:"arrival_time" json:"arrivalTime"`
	Frequency                        string               `db:"frequency" json:"frequency"`
	CiTimeID                         pgtype.Text          `db:"ci_time_id" json:"ciTimeId"`
	Notes                            pgtype.Text          `db:"notes" json:"notes"`
	PriceType                        string               `db:"price_type" json:"priceType"`
	AdultPrice                       pgtype.Numeric       `db:"adult_price" json:"adultPrice"`
	ChildPrice                       pgtype.Numeric       `db:"child_price" json:"childPrice"`
	InfantPrice                      pgtype.Numeric       `db:"infant_price" json:"infantPrice"`
	ServiceRoutePricingExcludedDates []pgtype.Timestamptz `db:"service_route_pricing_excluded_dates" json:"serviceRoutePricingExcludedDates"`
	ServiceRoutePricingSoldOutDates  []pgtype.Timestamptz `db:"service_route_pricing_sold_out_dates" json:"serviceRoutePricingSoldOutDates"`
	FareTypeName                     string               `db:"fare_type_name" json:"fareTypeName"`
	StartStationName                 string               `db:"start_station_name" json:"startStationName"`
	StartStationAddress              string               `db:"start_station_address" json:"startStationAddress"`
	EndStationName                   string               `db:"end_station_name" json:"endStationName"`
	EndStationAddress                string               `db:"end_station_address" json:"endStationAddress"`
}

func (q *Queries) ServiceRouteAvailabilitiesSearch(ctx context.Context, arg ServiceRouteAvailabilitiesSearchParams) ([]ServiceRouteAvailabilitiesSearchRow, error) {
	rows, err := q.db.Query(ctx, serviceRouteAvailabilitiesSearch,
		arg.ProductTypeSlug,
		arg.StartLocationID,
		arg.EndLocationID,
		arg.SearchStartDate,
		arg.SearchEndDate,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ServiceRouteAvailabilitiesSearchRow
	for rows.Next() {
		var i ServiceRouteAvailabilitiesSearchRow
		if err := rows.Scan(
			&i.Name,
			&i.SubServiceName,
			&i.Description,
			&i.ServiceExcludedDates,
			&i.ServiceSoldOutDates,
			&i.StartStationID,
			&i.EndStationID,
			&i.IsActive,
			&i.IsMainRoute,
			&i.IcRouteID,
			&i.StartDate,
			&i.EndDate,
			&i.DepartureTime,
			&i.ArrivalTime,
			&i.Frequency,
			&i.CiTimeID,
			&i.Notes,
			&i.PriceType,
			&i.AdultPrice,
			&i.ChildPrice,
			&i.InfantPrice,
			&i.ServiceRoutePricingExcludedDates,
			&i.ServiceRoutePricingSoldOutDates,
			&i.FareTypeName,
			&i.StartStationName,
			&i.StartStationAddress,
			&i.EndStationName,
			&i.EndStationAddress,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateServiceRouteAvailability = `-- name: UpdateServiceRouteAvailability :one
UPDATE service_route_availability
SET
    modified = now() AT TIME ZONE 'UTC',
    service_route_id = $2,
    departure_time = $3,
    arrival_time = $4,
    frequency = $5,
    start_date = $6,
    end_date = $7,
    excluded_dates = $8,
    sold_out_dates = $9,
    ci_time_id = $10,
    notes = $11,
    is_active = $12
WHERE id = $1
RETURNING id, created, modified, service_route_id, departure_time, arrival_time, frequency, start_date, end_date, excluded_dates, sold_out_dates, ci_time_id, notes, is_active
`

type UpdateServiceRouteAvailabilityParams struct {
	ID             pgtype.UUID          `db:"id" json:"id"`
	ServiceRouteID pgtype.UUID          `db:"service_route_id" json:"serviceRouteId"`
	DepartureTime  pgtype.Timestamptz   `db:"departure_time" json:"departureTime"`
	ArrivalTime    pgtype.Timestamptz   `db:"arrival_time" json:"arrivalTime"`
	Frequency      string               `db:"frequency" json:"frequency"`
	StartDate      pgtype.Timestamptz   `db:"start_date" json:"startDate"`
	EndDate        pgtype.Timestamptz   `db:"end_date" json:"endDate"`
	ExcludedDates  []pgtype.Timestamptz `db:"excluded_dates" json:"excludedDates"`
	SoldOutDates   []pgtype.Timestamptz `db:"sold_out_dates" json:"soldOutDates"`
	CiTimeID       pgtype.Text          `db:"ci_time_id" json:"ciTimeId"`
	Notes          pgtype.Text          `db:"notes" json:"notes"`
	IsActive       bool                 `db:"is_active" json:"isActive"`
}

func (q *Queries) UpdateServiceRouteAvailability(ctx context.Context, arg UpdateServiceRouteAvailabilityParams) (ServiceRouteAvailability, error) {
	row := q.db.QueryRow(ctx, updateServiceRouteAvailability,
		arg.ID,
		arg.ServiceRouteID,
		arg.DepartureTime,
		arg.ArrivalTime,
		arg.Frequency,
		arg.StartDate,
		arg.EndDate,
		arg.ExcludedDates,
		arg.SoldOutDates,
		arg.CiTimeID,
		arg.Notes,
		arg.IsActive,
	)
	var i ServiceRouteAvailability
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Modified,
		&i.ServiceRouteID,
		&i.DepartureTime,
		&i.ArrivalTime,
		&i.Frequency,
		&i.StartDate,
		&i.EndDate,
		&i.ExcludedDates,
		&i.SoldOutDates,
		&i.CiTimeID,
		&i.Notes,
		&i.IsActive,
	)
	return i, err
}

const upsertServiceRouteAvailability = `-- name: UpsertServiceRouteAvailability :one
INSERT INTO service_route_availability (
    id,
    created,
    modified,
    service_route_id,
    departure_time,
    arrival_time,
    frequency,
    start_date,
    end_date,
    excluded_dates,
    sold_out_dates,
    ci_time_id,
    notes,
    is_active
) VALUES (
             coalesce(nullif($12, uuid_nil()), uuid_generate_v4()),
             now() AT TIME ZONE 'UTC',
             now() AT TIME ZONE 'UTC',
             $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
         )
ON CONFLICT (id) DO UPDATE
    SET
        modified = now() AT TIME ZONE 'UTC',
        service_route_id = $1,
        departure_time = $2,
        arrival_time = $3,
        frequency = $4,
        start_date = $5,
        end_date = $6,
        excluded_dates = $7,
        sold_out_dates = $8,
        ci_time_id = $9,
        notes = $10,
        is_active = $11
RETURNING id, created, modified, service_route_id, departure_time, arrival_time, frequency, start_date, end_date, excluded_dates, sold_out_dates, ci_time_id, notes, is_active
`

type UpsertServiceRouteAvailabilityParams struct {
	ServiceRouteID pgtype.UUID          `db:"service_route_id" json:"serviceRouteId"`
	DepartureTime  pgtype.Timestamptz   `db:"departure_time" json:"departureTime"`
	ArrivalTime    pgtype.Timestamptz   `db:"arrival_time" json:"arrivalTime"`
	Frequency      string               `db:"frequency" json:"frequency"`
	StartDate      pgtype.Timestamptz   `db:"start_date" json:"startDate"`
	EndDate        pgtype.Timestamptz   `db:"end_date" json:"endDate"`
	ExcludedDates  []pgtype.Timestamptz `db:"excluded_dates" json:"excludedDates"`
	SoldOutDates   []pgtype.Timestamptz `db:"sold_out_dates" json:"soldOutDates"`
	CiTimeID       pgtype.Text          `db:"ci_time_id" json:"ciTimeId"`
	Notes          pgtype.Text          `db:"notes" json:"notes"`
	IsActive       bool                 `db:"is_active" json:"isActive"`
	ID             interface{}          `db:"id" json:"id"`
}

func (q *Queries) UpsertServiceRouteAvailability(ctx context.Context, arg UpsertServiceRouteAvailabilityParams) (ServiceRouteAvailability, error) {
	row := q.db.QueryRow(ctx, upsertServiceRouteAvailability,
		arg.ServiceRouteID,
		arg.DepartureTime,
		arg.ArrivalTime,
		arg.Frequency,
		arg.StartDate,
		arg.EndDate,
		arg.ExcludedDates,
		arg.SoldOutDates,
		arg.CiTimeID,
		arg.Notes,
		arg.IsActive,
		arg.ID,
	)
	var i ServiceRouteAvailability
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Modified,
		&i.ServiceRouteID,
		&i.DepartureTime,
		&i.ArrivalTime,
		&i.Frequency,
		&i.StartDate,
		&i.EndDate,
		&i.ExcludedDates,
		&i.SoldOutDates,
		&i.CiTimeID,
		&i.Notes,
		&i.IsActive,
	)
	return i, err
}
