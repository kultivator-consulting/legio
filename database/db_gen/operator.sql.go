// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: operator.sql

package db_gen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countOperators = `-- name: CountOperators :one
SELECT
    COUNT(id)
FROM operator
WHERE deleted > now() AT TIME ZONE 'UTC'
`

func (q *Queries) CountOperators(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countOperators)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createOperator = `-- name: CreateOperator :one
INSERT INTO operator (
    id,
    created,
    modified,
    deleted,
    operator_name,
    location_id,
    operator_code,
    instruction_cust,
    email_address,
    operator_description,
    operator_bio,
    video_url,
    star_rating,
    operator_image,
    website_url,
    zone_info,
    locale,
    fare_url,
    phone,
    is_pass_code,
    is_active
) VALUES (
             uuid_generate_v4(),
             now() AT TIME ZONE 'UTC',
             now() AT TIME ZONE 'UTC',
             'infinity'::timestamp AT TIME ZONE 'UTC',
             $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17
         )
RETURNING id, created, modified, deleted, operator_name, location_id, operator_code, instruction_cust, email_address, operator_description, operator_bio, video_url, star_rating, operator_image, website_url, zone_info, locale, fare_url, phone, is_pass_code, is_active
`

type CreateOperatorParams struct {
	OperatorName        string      `db:"operator_name" json:"operatorName"`
	LocationID          pgtype.UUID `db:"location_id" json:"locationId"`
	OperatorCode        pgtype.Text `db:"operator_code" json:"operatorCode"`
	InstructionCust     pgtype.Text `db:"instruction_cust" json:"instructionCust"`
	EmailAddress        pgtype.Text `db:"email_address" json:"emailAddress"`
	OperatorDescription pgtype.Text `db:"operator_description" json:"operatorDescription"`
	OperatorBio         pgtype.Text `db:"operator_bio" json:"operatorBio"`
	VideoUrl            pgtype.Text `db:"video_url" json:"videoUrl"`
	StarRating          int32       `db:"star_rating" json:"starRating"`
	OperatorImage       pgtype.Text `db:"operator_image" json:"operatorImage"`
	WebsiteUrl          pgtype.Text `db:"website_url" json:"websiteUrl"`
	ZoneInfo            string      `db:"zone_info" json:"zoneInfo"`
	Locale              string      `db:"locale" json:"locale"`
	FareUrl             string      `db:"fare_url" json:"fareUrl"`
	Phone               string      `db:"phone" json:"phone"`
	IsPassCode          bool        `db:"is_pass_code" json:"isPassCode"`
	IsActive            bool        `db:"is_active" json:"isActive"`
}

func (q *Queries) CreateOperator(ctx context.Context, arg CreateOperatorParams) (Operator, error) {
	row := q.db.QueryRow(ctx, createOperator,
		arg.OperatorName,
		arg.LocationID,
		arg.OperatorCode,
		arg.InstructionCust,
		arg.EmailAddress,
		arg.OperatorDescription,
		arg.OperatorBio,
		arg.VideoUrl,
		arg.StarRating,
		arg.OperatorImage,
		arg.WebsiteUrl,
		arg.ZoneInfo,
		arg.Locale,
		arg.FareUrl,
		arg.Phone,
		arg.IsPassCode,
		arg.IsActive,
	)
	var i Operator
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Modified,
		&i.Deleted,
		&i.OperatorName,
		&i.LocationID,
		&i.OperatorCode,
		&i.InstructionCust,
		&i.EmailAddress,
		&i.OperatorDescription,
		&i.OperatorBio,
		&i.VideoUrl,
		&i.StarRating,
		&i.OperatorImage,
		&i.WebsiteUrl,
		&i.ZoneInfo,
		&i.Locale,
		&i.FareUrl,
		&i.Phone,
		&i.IsPassCode,
		&i.IsActive,
	)
	return i, err
}

const createOperatorAndReturnId = `-- name: CreateOperatorAndReturnId :one
INSERT INTO operator (
    id,
    created,
    modified,
    deleted,
    operator_name,
    location_id,
    operator_code,
    instruction_cust,
    email_address,
    operator_description,
    operator_bio,
    video_url,
    star_rating,
    operator_image,
    website_url,
    zone_info,
    locale,
    fare_url,
    phone,
    is_pass_code,
    is_active
) VALUES (
             uuid_generate_v4(),
             now() AT TIME ZONE 'UTC',
             now() AT TIME ZONE 'UTC',
             'infinity'::timestamp AT TIME ZONE 'UTC',
             $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17
         )
RETURNING id
`

type CreateOperatorAndReturnIdParams struct {
	OperatorName        string      `db:"operator_name" json:"operatorName"`
	LocationID          pgtype.UUID `db:"location_id" json:"locationId"`
	OperatorCode        pgtype.Text `db:"operator_code" json:"operatorCode"`
	InstructionCust     pgtype.Text `db:"instruction_cust" json:"instructionCust"`
	EmailAddress        pgtype.Text `db:"email_address" json:"emailAddress"`
	OperatorDescription pgtype.Text `db:"operator_description" json:"operatorDescription"`
	OperatorBio         pgtype.Text `db:"operator_bio" json:"operatorBio"`
	VideoUrl            pgtype.Text `db:"video_url" json:"videoUrl"`
	StarRating          int32       `db:"star_rating" json:"starRating"`
	OperatorImage       pgtype.Text `db:"operator_image" json:"operatorImage"`
	WebsiteUrl          pgtype.Text `db:"website_url" json:"websiteUrl"`
	ZoneInfo            string      `db:"zone_info" json:"zoneInfo"`
	Locale              string      `db:"locale" json:"locale"`
	FareUrl             string      `db:"fare_url" json:"fareUrl"`
	Phone               string      `db:"phone" json:"phone"`
	IsPassCode          bool        `db:"is_pass_code" json:"isPassCode"`
	IsActive            bool        `db:"is_active" json:"isActive"`
}

func (q *Queries) CreateOperatorAndReturnId(ctx context.Context, arg CreateOperatorAndReturnIdParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, createOperatorAndReturnId,
		arg.OperatorName,
		arg.LocationID,
		arg.OperatorCode,
		arg.InstructionCust,
		arg.EmailAddress,
		arg.OperatorDescription,
		arg.OperatorBio,
		arg.VideoUrl,
		arg.StarRating,
		arg.OperatorImage,
		arg.WebsiteUrl,
		arg.ZoneInfo,
		arg.Locale,
		arg.FareUrl,
		arg.Phone,
		arg.IsPassCode,
		arg.IsActive,
	)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const deleteOperator = `-- name: DeleteOperator :exec
UPDATE operator
SET
    deleted = now() AT TIME ZONE 'UTC'
WHERE id = $1
`

func (q *Queries) DeleteOperator(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteOperator, id)
	return err
}

const getOperatorById = `-- name: GetOperatorById :one
SELECT id, created, modified, deleted, operator_name, location_id, operator_code, instruction_cust, email_address, operator_description, operator_bio, video_url, star_rating, operator_image, website_url, zone_info, locale, fare_url, phone, is_pass_code, is_active FROM operator
WHERE operator.id = $1
  AND deleted > now() AT TIME ZONE 'UTC'
LIMIT 1
`

func (q *Queries) GetOperatorById(ctx context.Context, id pgtype.UUID) (Operator, error) {
	row := q.db.QueryRow(ctx, getOperatorById, id)
	var i Operator
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Modified,
		&i.Deleted,
		&i.OperatorName,
		&i.LocationID,
		&i.OperatorCode,
		&i.InstructionCust,
		&i.EmailAddress,
		&i.OperatorDescription,
		&i.OperatorBio,
		&i.VideoUrl,
		&i.StarRating,
		&i.OperatorImage,
		&i.WebsiteUrl,
		&i.ZoneInfo,
		&i.Locale,
		&i.FareUrl,
		&i.Phone,
		&i.IsPassCode,
		&i.IsActive,
	)
	return i, err
}

const getOperatorByOperatorName = `-- name: GetOperatorByOperatorName :one
SELECT id, created, modified, deleted, operator_name, location_id, operator_code, instruction_cust, email_address, operator_description, operator_bio, video_url, star_rating, operator_image, website_url, zone_info, locale, fare_url, phone, is_pass_code, is_active FROM operator
WHERE operator.operator_name = $1
  AND deleted > now() AT TIME ZONE 'UTC'
  AND is_active = TRUE
LIMIT 1
`

func (q *Queries) GetOperatorByOperatorName(ctx context.Context, operatorName string) (Operator, error) {
	row := q.db.QueryRow(ctx, getOperatorByOperatorName, operatorName)
	var i Operator
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Modified,
		&i.Deleted,
		&i.OperatorName,
		&i.LocationID,
		&i.OperatorCode,
		&i.InstructionCust,
		&i.EmailAddress,
		&i.OperatorDescription,
		&i.OperatorBio,
		&i.VideoUrl,
		&i.StarRating,
		&i.OperatorImage,
		&i.WebsiteUrl,
		&i.ZoneInfo,
		&i.Locale,
		&i.FareUrl,
		&i.Phone,
		&i.IsPassCode,
		&i.IsActive,
	)
	return i, err
}

const listOperatorsAsc = `-- name: ListOperatorsAsc :many
SELECT id, created, modified, deleted, operator_name, location_id, operator_code, instruction_cust, email_address, operator_description, operator_bio, video_url, star_rating, operator_image, website_url, zone_info, locale, fare_url, phone, is_pass_code, is_active FROM operator
WHERE deleted > now() AT TIME ZONE 'UTC'
ORDER BY $1::text
OFFSET ($2::int - 1) * $3::int
    FETCH NEXT $3 ROWS ONLY
`

type ListOperatorsAscParams struct {
	SortBy            string `db:"sort_by" json:"sortBy"`
	RequestedPage     int32  `db:"requested_page" json:"requestedPage"`
	RequestedPageSize int32  `db:"requested_page_size" json:"requestedPageSize"`
}

func (q *Queries) ListOperatorsAsc(ctx context.Context, arg ListOperatorsAscParams) ([]Operator, error) {
	rows, err := q.db.Query(ctx, listOperatorsAsc, arg.SortBy, arg.RequestedPage, arg.RequestedPageSize)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Operator
	for rows.Next() {
		var i Operator
		if err := rows.Scan(
			&i.ID,
			&i.Created,
			&i.Modified,
			&i.Deleted,
			&i.OperatorName,
			&i.LocationID,
			&i.OperatorCode,
			&i.InstructionCust,
			&i.EmailAddress,
			&i.OperatorDescription,
			&i.OperatorBio,
			&i.VideoUrl,
			&i.StarRating,
			&i.OperatorImage,
			&i.WebsiteUrl,
			&i.ZoneInfo,
			&i.Locale,
			&i.FareUrl,
			&i.Phone,
			&i.IsPassCode,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOperatorsByPassCode = `-- name: ListOperatorsByPassCode :many
SELECT id, created, modified, deleted, operator_name, location_id, operator_code, instruction_cust, email_address, operator_description, operator_bio, video_url, star_rating, operator_image, website_url, zone_info, locale, fare_url, phone, is_pass_code, is_active FROM operator
WHERE is_pass_code = TRUE
  AND deleted > now() AT TIME ZONE 'UTC'
`

func (q *Queries) ListOperatorsByPassCode(ctx context.Context) ([]Operator, error) {
	rows, err := q.db.Query(ctx, listOperatorsByPassCode)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Operator
	for rows.Next() {
		var i Operator
		if err := rows.Scan(
			&i.ID,
			&i.Created,
			&i.Modified,
			&i.Deleted,
			&i.OperatorName,
			&i.LocationID,
			&i.OperatorCode,
			&i.InstructionCust,
			&i.EmailAddress,
			&i.OperatorDescription,
			&i.OperatorBio,
			&i.VideoUrl,
			&i.StarRating,
			&i.OperatorImage,
			&i.WebsiteUrl,
			&i.ZoneInfo,
			&i.Locale,
			&i.FareUrl,
			&i.Phone,
			&i.IsPassCode,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOperatorsDesc = `-- name: ListOperatorsDesc :many
SELECT id, created, modified, deleted, operator_name, location_id, operator_code, instruction_cust, email_address, operator_description, operator_bio, video_url, star_rating, operator_image, website_url, zone_info, locale, fare_url, phone, is_pass_code, is_active FROM operator
WHERE deleted > now() AT TIME ZONE 'UTC'
ORDER BY $1::text DESC
OFFSET ($2::int - 1) * $3::int
    FETCH NEXT $3 ROWS ONLY
`

type ListOperatorsDescParams struct {
	SortBy            string `db:"sort_by" json:"sortBy"`
	RequestedPage     int32  `db:"requested_page" json:"requestedPage"`
	RequestedPageSize int32  `db:"requested_page_size" json:"requestedPageSize"`
}

func (q *Queries) ListOperatorsDesc(ctx context.Context, arg ListOperatorsDescParams) ([]Operator, error) {
	rows, err := q.db.Query(ctx, listOperatorsDesc, arg.SortBy, arg.RequestedPage, arg.RequestedPageSize)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Operator
	for rows.Next() {
		var i Operator
		if err := rows.Scan(
			&i.ID,
			&i.Created,
			&i.Modified,
			&i.Deleted,
			&i.OperatorName,
			&i.LocationID,
			&i.OperatorCode,
			&i.InstructionCust,
			&i.EmailAddress,
			&i.OperatorDescription,
			&i.OperatorBio,
			&i.VideoUrl,
			&i.StarRating,
			&i.OperatorImage,
			&i.WebsiteUrl,
			&i.ZoneInfo,
			&i.Locale,
			&i.FareUrl,
			&i.Phone,
			&i.IsPassCode,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateOperator = `-- name: UpdateOperator :one
UPDATE operator
SET
    modified = now() AT TIME ZONE 'UTC',
    operator_name = $2,
    location_id = $3,
    operator_code = $4,
    instruction_cust = $5,
    email_address = $6,
    operator_description = $7,
    operator_bio = $8,
    video_url = $9,
    star_rating = $10,
    operator_image = $11,
    website_url = $12,
    zone_info = $13,
    locale = $14,
    fare_url = $15,
    phone = $16,
    is_pass_code = $17,
    is_active = $18
WHERE id = $1
RETURNING id, created, modified, deleted, operator_name, location_id, operator_code, instruction_cust, email_address, operator_description, operator_bio, video_url, star_rating, operator_image, website_url, zone_info, locale, fare_url, phone, is_pass_code, is_active
`

type UpdateOperatorParams struct {
	ID                  pgtype.UUID `db:"id" json:"id"`
	OperatorName        string      `db:"operator_name" json:"operatorName"`
	LocationID          pgtype.UUID `db:"location_id" json:"locationId"`
	OperatorCode        pgtype.Text `db:"operator_code" json:"operatorCode"`
	InstructionCust     pgtype.Text `db:"instruction_cust" json:"instructionCust"`
	EmailAddress        pgtype.Text `db:"email_address" json:"emailAddress"`
	OperatorDescription pgtype.Text `db:"operator_description" json:"operatorDescription"`
	OperatorBio         pgtype.Text `db:"operator_bio" json:"operatorBio"`
	VideoUrl            pgtype.Text `db:"video_url" json:"videoUrl"`
	StarRating          int32       `db:"star_rating" json:"starRating"`
	OperatorImage       pgtype.Text `db:"operator_image" json:"operatorImage"`
	WebsiteUrl          pgtype.Text `db:"website_url" json:"websiteUrl"`
	ZoneInfo            string      `db:"zone_info" json:"zoneInfo"`
	Locale              string      `db:"locale" json:"locale"`
	FareUrl             string      `db:"fare_url" json:"fareUrl"`
	Phone               string      `db:"phone" json:"phone"`
	IsPassCode          bool        `db:"is_pass_code" json:"isPassCode"`
	IsActive            bool        `db:"is_active" json:"isActive"`
}

func (q *Queries) UpdateOperator(ctx context.Context, arg UpdateOperatorParams) (Operator, error) {
	row := q.db.QueryRow(ctx, updateOperator,
		arg.ID,
		arg.OperatorName,
		arg.LocationID,
		arg.OperatorCode,
		arg.InstructionCust,
		arg.EmailAddress,
		arg.OperatorDescription,
		arg.OperatorBio,
		arg.VideoUrl,
		arg.StarRating,
		arg.OperatorImage,
		arg.WebsiteUrl,
		arg.ZoneInfo,
		arg.Locale,
		arg.FareUrl,
		arg.Phone,
		arg.IsPassCode,
		arg.IsActive,
	)
	var i Operator
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Modified,
		&i.Deleted,
		&i.OperatorName,
		&i.LocationID,
		&i.OperatorCode,
		&i.InstructionCust,
		&i.EmailAddress,
		&i.OperatorDescription,
		&i.OperatorBio,
		&i.VideoUrl,
		&i.StarRating,
		&i.OperatorImage,
		&i.WebsiteUrl,
		&i.ZoneInfo,
		&i.Locale,
		&i.FareUrl,
		&i.Phone,
		&i.IsPassCode,
		&i.IsActive,
	)
	return i, err
}
