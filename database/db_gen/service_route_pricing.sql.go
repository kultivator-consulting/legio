// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: service_route_pricing.sql

package db_gen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countServiceRouteAvailabilityPricesByServiceRouteAvailabilityId = `-- name: CountServiceRouteAvailabilityPricesByServiceRouteAvailabilityId :one
SELECT
    COUNT(id)
FROM service_route_pricing
WHERE service_route_availability_id = $1
`

func (q *Queries) CountServiceRouteAvailabilityPricesByServiceRouteAvailabilityId(ctx context.Context, serviceRouteAvailabilityID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countServiceRouteAvailabilityPricesByServiceRouteAvailabilityId, serviceRouteAvailabilityID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countServiceRouteAvailabilityPricesByServiceRouteAvailabilityIdAndDateRange = `-- name: CountServiceRouteAvailabilityPricesByServiceRouteAvailabilityIdAndDateRange :one
SELECT
    COUNT(id)
FROM service_route_pricing
WHERE service_route_availability_id = $1 AND start_date <= $2 AND end_date >= $3
`

type CountServiceRouteAvailabilityPricesByServiceRouteAvailabilityIdAndDateRangeParams struct {
	ServiceRouteAvailabilityID pgtype.UUID        `db:"service_route_availability_id" json:"serviceRouteAvailabilityId"`
	StartDate                  pgtype.Timestamptz `db:"start_date" json:"startDate"`
	EndDate                    pgtype.Timestamptz `db:"end_date" json:"endDate"`
}

func (q *Queries) CountServiceRouteAvailabilityPricesByServiceRouteAvailabilityIdAndDateRange(ctx context.Context, arg CountServiceRouteAvailabilityPricesByServiceRouteAvailabilityIdAndDateRangeParams) (int64, error) {
	row := q.db.QueryRow(ctx, countServiceRouteAvailabilityPricesByServiceRouteAvailabilityIdAndDateRange, arg.ServiceRouteAvailabilityID, arg.StartDate, arg.EndDate)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countServiceRouteAvailabilityPricesByServiceRouteAvailabilityIdAndDateRangeAndFareTypeId = `-- name: CountServiceRouteAvailabilityPricesByServiceRouteAvailabilityIdAndDateRangeAndFareTypeId :one
SELECT
    COUNT(id)
FROM service_route_pricing
WHERE service_route_availability_id = $1 AND fare_type_id = $2 AND start_date <= $3 AND end_date >= $4
`

type CountServiceRouteAvailabilityPricesByServiceRouteAvailabilityIdAndDateRangeAndFareTypeIdParams struct {
	ServiceRouteAvailabilityID pgtype.UUID        `db:"service_route_availability_id" json:"serviceRouteAvailabilityId"`
	FareTypeID                 pgtype.UUID        `db:"fare_type_id" json:"fareTypeId"`
	StartDate                  pgtype.Timestamptz `db:"start_date" json:"startDate"`
	EndDate                    pgtype.Timestamptz `db:"end_date" json:"endDate"`
}

func (q *Queries) CountServiceRouteAvailabilityPricesByServiceRouteAvailabilityIdAndDateRangeAndFareTypeId(ctx context.Context, arg CountServiceRouteAvailabilityPricesByServiceRouteAvailabilityIdAndDateRangeAndFareTypeIdParams) (int64, error) {
	row := q.db.QueryRow(ctx, countServiceRouteAvailabilityPricesByServiceRouteAvailabilityIdAndDateRangeAndFareTypeId,
		arg.ServiceRouteAvailabilityID,
		arg.FareTypeID,
		arg.StartDate,
		arg.EndDate,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createServiceRouteAvailabilityPricing = `-- name: CreateServiceRouteAvailabilityPricing :one
INSERT INTO service_route_pricing (
    id,
    created,
    modified,
    service_route_availability_id,
    fare_type_id,
    price_type,
    adult_price,
    child_price,
    infant_price,
    start_date,
    end_date,
    excluded_dates,
    sold_out_dates,
    specific_terms,
    is_active
) VALUES (
             uuid_generate_v4(),
             now() AT TIME ZONE 'UTC',
             now() AT TIME ZONE 'UTC',
             $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12
         )
RETURNING id, created, modified, service_route_availability_id, fare_type_id, price_type, adult_price, child_price, infant_price, start_date, end_date, excluded_dates, sold_out_dates, specific_terms, is_active
`

type CreateServiceRouteAvailabilityPricingParams struct {
	ServiceRouteAvailabilityID pgtype.UUID          `db:"service_route_availability_id" json:"serviceRouteAvailabilityId"`
	FareTypeID                 pgtype.UUID          `db:"fare_type_id" json:"fareTypeId"`
	PriceType                  string               `db:"price_type" json:"priceType"`
	AdultPrice                 pgtype.Numeric       `db:"adult_price" json:"adultPrice"`
	ChildPrice                 pgtype.Numeric       `db:"child_price" json:"childPrice"`
	InfantPrice                pgtype.Numeric       `db:"infant_price" json:"infantPrice"`
	StartDate                  pgtype.Timestamptz   `db:"start_date" json:"startDate"`
	EndDate                    pgtype.Timestamptz   `db:"end_date" json:"endDate"`
	ExcludedDates              []pgtype.Timestamptz `db:"excluded_dates" json:"excludedDates"`
	SoldOutDates               []pgtype.Timestamptz `db:"sold_out_dates" json:"soldOutDates"`
	SpecificTerms              string               `db:"specific_terms" json:"specificTerms"`
	IsActive                   bool                 `db:"is_active" json:"isActive"`
}

func (q *Queries) CreateServiceRouteAvailabilityPricing(ctx context.Context, arg CreateServiceRouteAvailabilityPricingParams) (ServiceRoutePricing, error) {
	row := q.db.QueryRow(ctx, createServiceRouteAvailabilityPricing,
		arg.ServiceRouteAvailabilityID,
		arg.FareTypeID,
		arg.PriceType,
		arg.AdultPrice,
		arg.ChildPrice,
		arg.InfantPrice,
		arg.StartDate,
		arg.EndDate,
		arg.ExcludedDates,
		arg.SoldOutDates,
		arg.SpecificTerms,
		arg.IsActive,
	)
	var i ServiceRoutePricing
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Modified,
		&i.ServiceRouteAvailabilityID,
		&i.FareTypeID,
		&i.PriceType,
		&i.AdultPrice,
		&i.ChildPrice,
		&i.InfantPrice,
		&i.StartDate,
		&i.EndDate,
		&i.ExcludedDates,
		&i.SoldOutDates,
		&i.SpecificTerms,
		&i.IsActive,
	)
	return i, err
}

const deleteServiceRouteAvailabilityPricing = `-- name: DeleteServiceRouteAvailabilityPricing :exec
DELETE FROM service_route_pricing
WHERE id = $1
`

func (q *Queries) DeleteServiceRouteAvailabilityPricing(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteServiceRouteAvailabilityPricing, id)
	return err
}

const deleteServiceRouteAvailabilityPricingByServiceRouteAvailabilityId = `-- name: DeleteServiceRouteAvailabilityPricingByServiceRouteAvailabilityId :exec
DELETE FROM service_route_pricing
WHERE service_route_availability_id = $1
`

func (q *Queries) DeleteServiceRouteAvailabilityPricingByServiceRouteAvailabilityId(ctx context.Context, serviceRouteAvailabilityID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteServiceRouteAvailabilityPricingByServiceRouteAvailabilityId, serviceRouteAvailabilityID)
	return err
}

const getServiceRouteAvailabilityPricingById = `-- name: GetServiceRouteAvailabilityPricingById :one
SELECT id, created, modified, service_route_availability_id, fare_type_id, price_type, adult_price, child_price, infant_price, start_date, end_date, excluded_dates, sold_out_dates, specific_terms, is_active FROM service_route_pricing
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetServiceRouteAvailabilityPricingById(ctx context.Context, id pgtype.UUID) (ServiceRoutePricing, error) {
	row := q.db.QueryRow(ctx, getServiceRouteAvailabilityPricingById, id)
	var i ServiceRoutePricing
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Modified,
		&i.ServiceRouteAvailabilityID,
		&i.FareTypeID,
		&i.PriceType,
		&i.AdultPrice,
		&i.ChildPrice,
		&i.InfantPrice,
		&i.StartDate,
		&i.EndDate,
		&i.ExcludedDates,
		&i.SoldOutDates,
		&i.SpecificTerms,
		&i.IsActive,
	)
	return i, err
}

const getServiceRouteAvailabilityPricingByServiceRouteAvailabilityIdAndFareTypeId = `-- name: GetServiceRouteAvailabilityPricingByServiceRouteAvailabilityIdAndFareTypeId :one
SELECT id, created, modified, service_route_availability_id, fare_type_id, price_type, adult_price, child_price, infant_price, start_date, end_date, excluded_dates, sold_out_dates, specific_terms, is_active FROM service_route_pricing
WHERE service_route_availability_id = $1 AND fare_type_id = $2
LIMIT 1
`

type GetServiceRouteAvailabilityPricingByServiceRouteAvailabilityIdAndFareTypeIdParams struct {
	ServiceRouteAvailabilityID pgtype.UUID `db:"service_route_availability_id" json:"serviceRouteAvailabilityId"`
	FareTypeID                 pgtype.UUID `db:"fare_type_id" json:"fareTypeId"`
}

func (q *Queries) GetServiceRouteAvailabilityPricingByServiceRouteAvailabilityIdAndFareTypeId(ctx context.Context, arg GetServiceRouteAvailabilityPricingByServiceRouteAvailabilityIdAndFareTypeIdParams) (ServiceRoutePricing, error) {
	row := q.db.QueryRow(ctx, getServiceRouteAvailabilityPricingByServiceRouteAvailabilityIdAndFareTypeId, arg.ServiceRouteAvailabilityID, arg.FareTypeID)
	var i ServiceRoutePricing
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Modified,
		&i.ServiceRouteAvailabilityID,
		&i.FareTypeID,
		&i.PriceType,
		&i.AdultPrice,
		&i.ChildPrice,
		&i.InfantPrice,
		&i.StartDate,
		&i.EndDate,
		&i.ExcludedDates,
		&i.SoldOutDates,
		&i.SpecificTerms,
		&i.IsActive,
	)
	return i, err
}

const listServiceRouteAvailabilityPricesByServiceRouteAvailabilityId = `-- name: ListServiceRouteAvailabilityPricesByServiceRouteAvailabilityId :many
SELECT id, created, modified, service_route_availability_id, fare_type_id, price_type, adult_price, child_price, infant_price, start_date, end_date, excluded_dates, sold_out_dates, specific_terms, is_active FROM service_route_pricing
WHERE service_route_availability_id = $1
`

func (q *Queries) ListServiceRouteAvailabilityPricesByServiceRouteAvailabilityId(ctx context.Context, serviceRouteAvailabilityID pgtype.UUID) ([]ServiceRoutePricing, error) {
	rows, err := q.db.Query(ctx, listServiceRouteAvailabilityPricesByServiceRouteAvailabilityId, serviceRouteAvailabilityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ServiceRoutePricing
	for rows.Next() {
		var i ServiceRoutePricing
		if err := rows.Scan(
			&i.ID,
			&i.Created,
			&i.Modified,
			&i.ServiceRouteAvailabilityID,
			&i.FareTypeID,
			&i.PriceType,
			&i.AdultPrice,
			&i.ChildPrice,
			&i.InfantPrice,
			&i.StartDate,
			&i.EndDate,
			&i.ExcludedDates,
			&i.SoldOutDates,
			&i.SpecificTerms,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listServiceRouteAvailabilityPricesByServiceRouteAvailabilityIdAndDateRange = `-- name: ListServiceRouteAvailabilityPricesByServiceRouteAvailabilityIdAndDateRange :many
SELECT id, created, modified, service_route_availability_id, fare_type_id, price_type, adult_price, child_price, infant_price, start_date, end_date, excluded_dates, sold_out_dates, specific_terms, is_active FROM service_route_pricing
WHERE service_route_availability_id = $1 AND start_date <= $2 AND end_date >= $3
`

type ListServiceRouteAvailabilityPricesByServiceRouteAvailabilityIdAndDateRangeParams struct {
	ServiceRouteAvailabilityID pgtype.UUID        `db:"service_route_availability_id" json:"serviceRouteAvailabilityId"`
	StartDate                  pgtype.Timestamptz `db:"start_date" json:"startDate"`
	EndDate                    pgtype.Timestamptz `db:"end_date" json:"endDate"`
}

func (q *Queries) ListServiceRouteAvailabilityPricesByServiceRouteAvailabilityIdAndDateRange(ctx context.Context, arg ListServiceRouteAvailabilityPricesByServiceRouteAvailabilityIdAndDateRangeParams) ([]ServiceRoutePricing, error) {
	rows, err := q.db.Query(ctx, listServiceRouteAvailabilityPricesByServiceRouteAvailabilityIdAndDateRange, arg.ServiceRouteAvailabilityID, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ServiceRoutePricing
	for rows.Next() {
		var i ServiceRoutePricing
		if err := rows.Scan(
			&i.ID,
			&i.Created,
			&i.Modified,
			&i.ServiceRouteAvailabilityID,
			&i.FareTypeID,
			&i.PriceType,
			&i.AdultPrice,
			&i.ChildPrice,
			&i.InfantPrice,
			&i.StartDate,
			&i.EndDate,
			&i.ExcludedDates,
			&i.SoldOutDates,
			&i.SpecificTerms,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listServiceRouteAvailabilityPricesByServiceRouteAvailabilityIdAndDateRangeAndFareTypeId = `-- name: ListServiceRouteAvailabilityPricesByServiceRouteAvailabilityIdAndDateRangeAndFareTypeId :many
SELECT id, created, modified, service_route_availability_id, fare_type_id, price_type, adult_price, child_price, infant_price, start_date, end_date, excluded_dates, sold_out_dates, specific_terms, is_active FROM service_route_pricing
WHERE service_route_availability_id = $1 AND fare_type_id = $2 AND start_date <= $3 AND end_date >= $4
`

type ListServiceRouteAvailabilityPricesByServiceRouteAvailabilityIdAndDateRangeAndFareTypeIdParams struct {
	ServiceRouteAvailabilityID pgtype.UUID        `db:"service_route_availability_id" json:"serviceRouteAvailabilityId"`
	FareTypeID                 pgtype.UUID        `db:"fare_type_id" json:"fareTypeId"`
	StartDate                  pgtype.Timestamptz `db:"start_date" json:"startDate"`
	EndDate                    pgtype.Timestamptz `db:"end_date" json:"endDate"`
}

func (q *Queries) ListServiceRouteAvailabilityPricesByServiceRouteAvailabilityIdAndDateRangeAndFareTypeId(ctx context.Context, arg ListServiceRouteAvailabilityPricesByServiceRouteAvailabilityIdAndDateRangeAndFareTypeIdParams) ([]ServiceRoutePricing, error) {
	rows, err := q.db.Query(ctx, listServiceRouteAvailabilityPricesByServiceRouteAvailabilityIdAndDateRangeAndFareTypeId,
		arg.ServiceRouteAvailabilityID,
		arg.FareTypeID,
		arg.StartDate,
		arg.EndDate,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ServiceRoutePricing
	for rows.Next() {
		var i ServiceRoutePricing
		if err := rows.Scan(
			&i.ID,
			&i.Created,
			&i.Modified,
			&i.ServiceRouteAvailabilityID,
			&i.FareTypeID,
			&i.PriceType,
			&i.AdultPrice,
			&i.ChildPrice,
			&i.InfantPrice,
			&i.StartDate,
			&i.EndDate,
			&i.ExcludedDates,
			&i.SoldOutDates,
			&i.SpecificTerms,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateServiceRouteAvailabilityPricing = `-- name: UpdateServiceRouteAvailabilityPricing :one
UPDATE service_route_pricing
SET
    modified = now() AT TIME ZONE 'UTC',
    service_route_availability_id = $2,
    fare_type_id = $3,
    price_type = $4,
    adult_price = $5,
    child_price = $6,
    infant_price = $7,
    start_date = $8,
    end_date = $9,
    excluded_dates = $10,
    sold_out_dates = $11,
    specific_terms = $12,
    is_active = $13
WHERE id = $1
RETURNING id, created, modified, service_route_availability_id, fare_type_id, price_type, adult_price, child_price, infant_price, start_date, end_date, excluded_dates, sold_out_dates, specific_terms, is_active
`

type UpdateServiceRouteAvailabilityPricingParams struct {
	ID                         pgtype.UUID          `db:"id" json:"id"`
	ServiceRouteAvailabilityID pgtype.UUID          `db:"service_route_availability_id" json:"serviceRouteAvailabilityId"`
	FareTypeID                 pgtype.UUID          `db:"fare_type_id" json:"fareTypeId"`
	PriceType                  string               `db:"price_type" json:"priceType"`
	AdultPrice                 pgtype.Numeric       `db:"adult_price" json:"adultPrice"`
	ChildPrice                 pgtype.Numeric       `db:"child_price" json:"childPrice"`
	InfantPrice                pgtype.Numeric       `db:"infant_price" json:"infantPrice"`
	StartDate                  pgtype.Timestamptz   `db:"start_date" json:"startDate"`
	EndDate                    pgtype.Timestamptz   `db:"end_date" json:"endDate"`
	ExcludedDates              []pgtype.Timestamptz `db:"excluded_dates" json:"excludedDates"`
	SoldOutDates               []pgtype.Timestamptz `db:"sold_out_dates" json:"soldOutDates"`
	SpecificTerms              string               `db:"specific_terms" json:"specificTerms"`
	IsActive                   bool                 `db:"is_active" json:"isActive"`
}

func (q *Queries) UpdateServiceRouteAvailabilityPricing(ctx context.Context, arg UpdateServiceRouteAvailabilityPricingParams) (ServiceRoutePricing, error) {
	row := q.db.QueryRow(ctx, updateServiceRouteAvailabilityPricing,
		arg.ID,
		arg.ServiceRouteAvailabilityID,
		arg.FareTypeID,
		arg.PriceType,
		arg.AdultPrice,
		arg.ChildPrice,
		arg.InfantPrice,
		arg.StartDate,
		arg.EndDate,
		arg.ExcludedDates,
		arg.SoldOutDates,
		arg.SpecificTerms,
		arg.IsActive,
	)
	var i ServiceRoutePricing
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Modified,
		&i.ServiceRouteAvailabilityID,
		&i.FareTypeID,
		&i.PriceType,
		&i.AdultPrice,
		&i.ChildPrice,
		&i.InfantPrice,
		&i.StartDate,
		&i.EndDate,
		&i.ExcludedDates,
		&i.SoldOutDates,
		&i.SpecificTerms,
		&i.IsActive,
	)
	return i, err
}

const upsertServiceRouteAvailabilityPricing = `-- name: UpsertServiceRouteAvailabilityPricing :one
INSERT INTO service_route_pricing (
    id,
    created,
    modified,
    service_route_availability_id,
    fare_type_id,
    price_type,
    adult_price,
    child_price,
    infant_price,
    start_date,
    end_date,
    excluded_dates,
    sold_out_dates,
    specific_terms,
    is_active
) VALUES (
             coalesce(nullif($13, uuid_nil()), uuid_generate_v4()),
             now() AT TIME ZONE 'UTC',
             now() AT TIME ZONE 'UTC',
             $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12
         )
ON CONFLICT (id) DO UPDATE
    SET
        modified = now() AT TIME ZONE 'UTC',
        service_route_availability_id = $1,
        fare_type_id = $2,
        price_type = $3,
        adult_price = $4,
        child_price = $5,
        infant_price = $6,
        start_date = $7,
        end_date = $8,
        excluded_dates = $9,
        sold_out_dates = $10,
        specific_terms = $11,
        is_active = $12
RETURNING id, created, modified, service_route_availability_id, fare_type_id, price_type, adult_price, child_price, infant_price, start_date, end_date, excluded_dates, sold_out_dates, specific_terms, is_active
`

type UpsertServiceRouteAvailabilityPricingParams struct {
	ServiceRouteAvailabilityID pgtype.UUID          `db:"service_route_availability_id" json:"serviceRouteAvailabilityId"`
	FareTypeID                 pgtype.UUID          `db:"fare_type_id" json:"fareTypeId"`
	PriceType                  string               `db:"price_type" json:"priceType"`
	AdultPrice                 pgtype.Numeric       `db:"adult_price" json:"adultPrice"`
	ChildPrice                 pgtype.Numeric       `db:"child_price" json:"childPrice"`
	InfantPrice                pgtype.Numeric       `db:"infant_price" json:"infantPrice"`
	StartDate                  pgtype.Timestamptz   `db:"start_date" json:"startDate"`
	EndDate                    pgtype.Timestamptz   `db:"end_date" json:"endDate"`
	ExcludedDates              []pgtype.Timestamptz `db:"excluded_dates" json:"excludedDates"`
	SoldOutDates               []pgtype.Timestamptz `db:"sold_out_dates" json:"soldOutDates"`
	SpecificTerms              string               `db:"specific_terms" json:"specificTerms"`
	IsActive                   bool                 `db:"is_active" json:"isActive"`
	ID                         interface{}          `db:"id" json:"id"`
}

func (q *Queries) UpsertServiceRouteAvailabilityPricing(ctx context.Context, arg UpsertServiceRouteAvailabilityPricingParams) (ServiceRoutePricing, error) {
	row := q.db.QueryRow(ctx, upsertServiceRouteAvailabilityPricing,
		arg.ServiceRouteAvailabilityID,
		arg.FareTypeID,
		arg.PriceType,
		arg.AdultPrice,
		arg.ChildPrice,
		arg.InfantPrice,
		arg.StartDate,
		arg.EndDate,
		arg.ExcludedDates,
		arg.SoldOutDates,
		arg.SpecificTerms,
		arg.IsActive,
		arg.ID,
	)
	var i ServiceRoutePricing
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Modified,
		&i.ServiceRouteAvailabilityID,
		&i.FareTypeID,
		&i.PriceType,
		&i.AdultPrice,
		&i.ChildPrice,
		&i.InfantPrice,
		&i.StartDate,
		&i.EndDate,
		&i.ExcludedDates,
		&i.SoldOutDates,
		&i.SpecificTerms,
		&i.IsActive,
	)
	return i, err
}
