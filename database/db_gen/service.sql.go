// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: service.sql

package db_gen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countServices = `-- name: CountServices :one
SELECT
    COUNT(id)
FROM service
WHERE deleted > now() AT TIME ZONE 'UTC'
`

func (q *Queries) CountServices(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countServices)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countServicesByOperatorId = `-- name: CountServicesByOperatorId :one
SELECT
    COUNT(id)
FROM service
WHERE deleted > now() AT TIME ZONE 'UTC'
    AND operator_id = $1
`

func (q *Queries) CountServicesByOperatorId(ctx context.Context, operatorID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countServicesByOperatorId, operatorID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countServicesByProductTypeId = `-- name: CountServicesByProductTypeId :one
SELECT
    COUNT(id)
FROM service
WHERE deleted > now() AT TIME ZONE 'UTC'
    AND product_type_id = $1
`

func (q *Queries) CountServicesByProductTypeId(ctx context.Context, productTypeID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countServicesByProductTypeId, productTypeID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createService = `-- name: CreateService :one
INSERT INTO service (
    id,
    created,
    modified,
    deleted,
    operator_id,
    product_type_id,
    name,
    sub_service_name,
    start_location_id,
    end_location_id,
    start_station_id,
    end_station_id,
    logo,
    banner_image,
    excluded_dates,
    sold_out_dates,
    is_popular,
    with_pass,
    is_tour,
    tour_name,
    description,
    day_excursion,
    multi_service,
    excursion_text,
    service_code,
    meta_title,
    meta_content,
    is_active
) VALUES (
             uuid_generate_v4(),
             now() AT TIME ZONE 'UTC',
             now() AT TIME ZONE 'UTC',
             'infinity'::timestamp AT TIME ZONE 'UTC',
             $1, $2, $3, $4, $5, $6,
             $7, $8, $9, $10, $11, $12,
             $13, $14, $15, $16, $17, $18, $19,
             $20, $21, $22, $23, $24
         )
RETURNING id, created, modified, deleted, operator_id, product_type_id, name, sub_service_name, start_location_id, end_location_id, start_station_id, end_station_id, logo, banner_image, excluded_dates, sold_out_dates, is_popular, with_pass, is_tour, tour_name, description, day_excursion, multi_service, excursion_text, service_code, meta_title, meta_content, is_active
`

type CreateServiceParams struct {
	OperatorID      pgtype.UUID          `db:"operator_id" json:"operatorId"`
	ProductTypeID   pgtype.UUID          `db:"product_type_id" json:"productTypeId"`
	Name            string               `db:"name" json:"name"`
	SubServiceName  pgtype.Text          `db:"sub_service_name" json:"subServiceName"`
	StartLocationID pgtype.UUID          `db:"start_location_id" json:"startLocationId"`
	EndLocationID   pgtype.UUID          `db:"end_location_id" json:"endLocationId"`
	StartStationID  pgtype.UUID          `db:"start_station_id" json:"startStationId"`
	EndStationID    pgtype.UUID          `db:"end_station_id" json:"endStationId"`
	Logo            pgtype.Text          `db:"logo" json:"logo"`
	BannerImage     pgtype.Text          `db:"banner_image" json:"bannerImage"`
	ExcludedDates   []pgtype.Timestamptz `db:"excluded_dates" json:"excludedDates"`
	SoldOutDates    []pgtype.Timestamptz `db:"sold_out_dates" json:"soldOutDates"`
	IsPopular       bool                 `db:"is_popular" json:"isPopular"`
	WithPass        bool                 `db:"with_pass" json:"withPass"`
	IsTour          bool                 `db:"is_tour" json:"isTour"`
	TourName        pgtype.Text          `db:"tour_name" json:"tourName"`
	Description     pgtype.Text          `db:"description" json:"description"`
	DayExcursion    bool                 `db:"day_excursion" json:"dayExcursion"`
	MultiService    bool                 `db:"multi_service" json:"multiService"`
	ExcursionText   pgtype.Text          `db:"excursion_text" json:"excursionText"`
	ServiceCode     pgtype.Text          `db:"service_code" json:"serviceCode"`
	MetaTitle       pgtype.Text          `db:"meta_title" json:"metaTitle"`
	MetaContent     pgtype.Text          `db:"meta_content" json:"metaContent"`
	IsActive        bool                 `db:"is_active" json:"isActive"`
}

func (q *Queries) CreateService(ctx context.Context, arg CreateServiceParams) (Service, error) {
	row := q.db.QueryRow(ctx, createService,
		arg.OperatorID,
		arg.ProductTypeID,
		arg.Name,
		arg.SubServiceName,
		arg.StartLocationID,
		arg.EndLocationID,
		arg.StartStationID,
		arg.EndStationID,
		arg.Logo,
		arg.BannerImage,
		arg.ExcludedDates,
		arg.SoldOutDates,
		arg.IsPopular,
		arg.WithPass,
		arg.IsTour,
		arg.TourName,
		arg.Description,
		arg.DayExcursion,
		arg.MultiService,
		arg.ExcursionText,
		arg.ServiceCode,
		arg.MetaTitle,
		arg.MetaContent,
		arg.IsActive,
	)
	var i Service
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Modified,
		&i.Deleted,
		&i.OperatorID,
		&i.ProductTypeID,
		&i.Name,
		&i.SubServiceName,
		&i.StartLocationID,
		&i.EndLocationID,
		&i.StartStationID,
		&i.EndStationID,
		&i.Logo,
		&i.BannerImage,
		&i.ExcludedDates,
		&i.SoldOutDates,
		&i.IsPopular,
		&i.WithPass,
		&i.IsTour,
		&i.TourName,
		&i.Description,
		&i.DayExcursion,
		&i.MultiService,
		&i.ExcursionText,
		&i.ServiceCode,
		&i.MetaTitle,
		&i.MetaContent,
		&i.IsActive,
	)
	return i, err
}

const deleteService = `-- name: DeleteService :exec
UPDATE service
SET
    deleted = now() AT TIME ZONE 'UTC'
WHERE id = $1
`

func (q *Queries) DeleteService(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteService, id)
	return err
}

const getServiceById = `-- name: GetServiceById :one
SELECT id, created, modified, deleted, operator_id, product_type_id, name, sub_service_name, start_location_id, end_location_id, start_station_id, end_station_id, logo, banner_image, excluded_dates, sold_out_dates, is_popular, with_pass, is_tour, tour_name, description, day_excursion, multi_service, excursion_text, service_code, meta_title, meta_content, is_active FROM service
WHERE id = $1
  AND deleted > now() AT TIME ZONE 'UTC'
LIMIT 1
`

func (q *Queries) GetServiceById(ctx context.Context, id pgtype.UUID) (Service, error) {
	row := q.db.QueryRow(ctx, getServiceById, id)
	var i Service
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Modified,
		&i.Deleted,
		&i.OperatorID,
		&i.ProductTypeID,
		&i.Name,
		&i.SubServiceName,
		&i.StartLocationID,
		&i.EndLocationID,
		&i.StartStationID,
		&i.EndStationID,
		&i.Logo,
		&i.BannerImage,
		&i.ExcludedDates,
		&i.SoldOutDates,
		&i.IsPopular,
		&i.WithPass,
		&i.IsTour,
		&i.TourName,
		&i.Description,
		&i.DayExcursion,
		&i.MultiService,
		&i.ExcursionText,
		&i.ServiceCode,
		&i.MetaTitle,
		&i.MetaContent,
		&i.IsActive,
	)
	return i, err
}

const getServiceByName = `-- name: GetServiceByName :one
SELECT id, created, modified, deleted, operator_id, product_type_id, name, sub_service_name, start_location_id, end_location_id, start_station_id, end_station_id, logo, banner_image, excluded_dates, sold_out_dates, is_popular, with_pass, is_tour, tour_name, description, day_excursion, multi_service, excursion_text, service_code, meta_title, meta_content, is_active FROM service
WHERE name = $1
  AND deleted > now() AT TIME ZONE 'UTC'
  AND is_active = TRUE
LIMIT 1
`

func (q *Queries) GetServiceByName(ctx context.Context, name string) (Service, error) {
	row := q.db.QueryRow(ctx, getServiceByName, name)
	var i Service
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Modified,
		&i.Deleted,
		&i.OperatorID,
		&i.ProductTypeID,
		&i.Name,
		&i.SubServiceName,
		&i.StartLocationID,
		&i.EndLocationID,
		&i.StartStationID,
		&i.EndStationID,
		&i.Logo,
		&i.BannerImage,
		&i.ExcludedDates,
		&i.SoldOutDates,
		&i.IsPopular,
		&i.WithPass,
		&i.IsTour,
		&i.TourName,
		&i.Description,
		&i.DayExcursion,
		&i.MultiService,
		&i.ExcursionText,
		&i.ServiceCode,
		&i.MetaTitle,
		&i.MetaContent,
		&i.IsActive,
	)
	return i, err
}

const listServicesAsc = `-- name: ListServicesAsc :many
SELECT id, created, modified, deleted, operator_id, product_type_id, name, sub_service_name, start_location_id, end_location_id, start_station_id, end_station_id, logo, banner_image, excluded_dates, sold_out_dates, is_popular, with_pass, is_tour, tour_name, description, day_excursion, multi_service, excursion_text, service_code, meta_title, meta_content, is_active FROM service
WHERE deleted > now() AT TIME ZONE 'UTC'
ORDER BY $1::text
OFFSET ($2::int - 1) * $3::int
    FETCH NEXT $3 ROWS ONLY
`

type ListServicesAscParams struct {
	SortBy            string `db:"sort_by" json:"sortBy"`
	RequestedPage     int32  `db:"requested_page" json:"requestedPage"`
	RequestedPageSize int32  `db:"requested_page_size" json:"requestedPageSize"`
}

func (q *Queries) ListServicesAsc(ctx context.Context, arg ListServicesAscParams) ([]Service, error) {
	rows, err := q.db.Query(ctx, listServicesAsc, arg.SortBy, arg.RequestedPage, arg.RequestedPageSize)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Service
	for rows.Next() {
		var i Service
		if err := rows.Scan(
			&i.ID,
			&i.Created,
			&i.Modified,
			&i.Deleted,
			&i.OperatorID,
			&i.ProductTypeID,
			&i.Name,
			&i.SubServiceName,
			&i.StartLocationID,
			&i.EndLocationID,
			&i.StartStationID,
			&i.EndStationID,
			&i.Logo,
			&i.BannerImage,
			&i.ExcludedDates,
			&i.SoldOutDates,
			&i.IsPopular,
			&i.WithPass,
			&i.IsTour,
			&i.TourName,
			&i.Description,
			&i.DayExcursion,
			&i.MultiService,
			&i.ExcursionText,
			&i.ServiceCode,
			&i.MetaTitle,
			&i.MetaContent,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listServicesByOperatorIdAsc = `-- name: ListServicesByOperatorIdAsc :many
SELECT id, created, modified, deleted, operator_id, product_type_id, name, sub_service_name, start_location_id, end_location_id, start_station_id, end_station_id, logo, banner_image, excluded_dates, sold_out_dates, is_popular, with_pass, is_tour, tour_name, description, day_excursion, multi_service, excursion_text, service_code, meta_title, meta_content, is_active FROM service
WHERE deleted > now() AT TIME ZONE 'UTC'
    AND operator_id = $1
ORDER BY $2::text
OFFSET ($3::int - 1) * $4::int
    FETCH NEXT $4 ROWS ONLY
`

type ListServicesByOperatorIdAscParams struct {
	OperatorID        pgtype.UUID `db:"operator_id" json:"operatorId"`
	SortBy            string      `db:"sort_by" json:"sortBy"`
	RequestedPage     int32       `db:"requested_page" json:"requestedPage"`
	RequestedPageSize int32       `db:"requested_page_size" json:"requestedPageSize"`
}

func (q *Queries) ListServicesByOperatorIdAsc(ctx context.Context, arg ListServicesByOperatorIdAscParams) ([]Service, error) {
	rows, err := q.db.Query(ctx, listServicesByOperatorIdAsc,
		arg.OperatorID,
		arg.SortBy,
		arg.RequestedPage,
		arg.RequestedPageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Service
	for rows.Next() {
		var i Service
		if err := rows.Scan(
			&i.ID,
			&i.Created,
			&i.Modified,
			&i.Deleted,
			&i.OperatorID,
			&i.ProductTypeID,
			&i.Name,
			&i.SubServiceName,
			&i.StartLocationID,
			&i.EndLocationID,
			&i.StartStationID,
			&i.EndStationID,
			&i.Logo,
			&i.BannerImage,
			&i.ExcludedDates,
			&i.SoldOutDates,
			&i.IsPopular,
			&i.WithPass,
			&i.IsTour,
			&i.TourName,
			&i.Description,
			&i.DayExcursion,
			&i.MultiService,
			&i.ExcursionText,
			&i.ServiceCode,
			&i.MetaTitle,
			&i.MetaContent,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listServicesByOperatorIdDesc = `-- name: ListServicesByOperatorIdDesc :many
SELECT id, created, modified, deleted, operator_id, product_type_id, name, sub_service_name, start_location_id, end_location_id, start_station_id, end_station_id, logo, banner_image, excluded_dates, sold_out_dates, is_popular, with_pass, is_tour, tour_name, description, day_excursion, multi_service, excursion_text, service_code, meta_title, meta_content, is_active FROM service
WHERE deleted > now() AT TIME ZONE 'UTC'
    AND operator_id = $1
ORDER BY $2::text DESC
OFFSET ($3::int - 1) * $4::int
    FETCH NEXT $4 ROWS ONLY
`

type ListServicesByOperatorIdDescParams struct {
	OperatorID        pgtype.UUID `db:"operator_id" json:"operatorId"`
	SortBy            string      `db:"sort_by" json:"sortBy"`
	RequestedPage     int32       `db:"requested_page" json:"requestedPage"`
	RequestedPageSize int32       `db:"requested_page_size" json:"requestedPageSize"`
}

func (q *Queries) ListServicesByOperatorIdDesc(ctx context.Context, arg ListServicesByOperatorIdDescParams) ([]Service, error) {
	rows, err := q.db.Query(ctx, listServicesByOperatorIdDesc,
		arg.OperatorID,
		arg.SortBy,
		arg.RequestedPage,
		arg.RequestedPageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Service
	for rows.Next() {
		var i Service
		if err := rows.Scan(
			&i.ID,
			&i.Created,
			&i.Modified,
			&i.Deleted,
			&i.OperatorID,
			&i.ProductTypeID,
			&i.Name,
			&i.SubServiceName,
			&i.StartLocationID,
			&i.EndLocationID,
			&i.StartStationID,
			&i.EndStationID,
			&i.Logo,
			&i.BannerImage,
			&i.ExcludedDates,
			&i.SoldOutDates,
			&i.IsPopular,
			&i.WithPass,
			&i.IsTour,
			&i.TourName,
			&i.Description,
			&i.DayExcursion,
			&i.MultiService,
			&i.ExcursionText,
			&i.ServiceCode,
			&i.MetaTitle,
			&i.MetaContent,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listServicesByProductTypeAsc = `-- name: ListServicesByProductTypeAsc :many
SELECT id, created, modified, deleted, operator_id, product_type_id, name, sub_service_name, start_location_id, end_location_id, start_station_id, end_station_id, logo, banner_image, excluded_dates, sold_out_dates, is_popular, with_pass, is_tour, tour_name, description, day_excursion, multi_service, excursion_text, service_code, meta_title, meta_content, is_active FROM service
WHERE deleted > now() AT TIME ZONE 'UTC'
    AND product_type_id = $1
ORDER BY $2::text
OFFSET ($3::int - 1) * $4::int
    FETCH NEXT $4 ROWS ONLY
`

type ListServicesByProductTypeAscParams struct {
	ProductTypeID     pgtype.UUID `db:"product_type_id" json:"productTypeId"`
	SortBy            string      `db:"sort_by" json:"sortBy"`
	RequestedPage     int32       `db:"requested_page" json:"requestedPage"`
	RequestedPageSize int32       `db:"requested_page_size" json:"requestedPageSize"`
}

func (q *Queries) ListServicesByProductTypeAsc(ctx context.Context, arg ListServicesByProductTypeAscParams) ([]Service, error) {
	rows, err := q.db.Query(ctx, listServicesByProductTypeAsc,
		arg.ProductTypeID,
		arg.SortBy,
		arg.RequestedPage,
		arg.RequestedPageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Service
	for rows.Next() {
		var i Service
		if err := rows.Scan(
			&i.ID,
			&i.Created,
			&i.Modified,
			&i.Deleted,
			&i.OperatorID,
			&i.ProductTypeID,
			&i.Name,
			&i.SubServiceName,
			&i.StartLocationID,
			&i.EndLocationID,
			&i.StartStationID,
			&i.EndStationID,
			&i.Logo,
			&i.BannerImage,
			&i.ExcludedDates,
			&i.SoldOutDates,
			&i.IsPopular,
			&i.WithPass,
			&i.IsTour,
			&i.TourName,
			&i.Description,
			&i.DayExcursion,
			&i.MultiService,
			&i.ExcursionText,
			&i.ServiceCode,
			&i.MetaTitle,
			&i.MetaContent,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listServicesByProductTypeDesc = `-- name: ListServicesByProductTypeDesc :many
SELECT id, created, modified, deleted, operator_id, product_type_id, name, sub_service_name, start_location_id, end_location_id, start_station_id, end_station_id, logo, banner_image, excluded_dates, sold_out_dates, is_popular, with_pass, is_tour, tour_name, description, day_excursion, multi_service, excursion_text, service_code, meta_title, meta_content, is_active FROM service
WHERE deleted > now() AT TIME ZONE 'UTC'
    AND product_type_id = $1
ORDER BY $2::text DESC
OFFSET ($3::int - 1) * $4::int
    FETCH NEXT $4 ROWS ONLY
`

type ListServicesByProductTypeDescParams struct {
	ProductTypeID     pgtype.UUID `db:"product_type_id" json:"productTypeId"`
	SortBy            string      `db:"sort_by" json:"sortBy"`
	RequestedPage     int32       `db:"requested_page" json:"requestedPage"`
	RequestedPageSize int32       `db:"requested_page_size" json:"requestedPageSize"`
}

func (q *Queries) ListServicesByProductTypeDesc(ctx context.Context, arg ListServicesByProductTypeDescParams) ([]Service, error) {
	rows, err := q.db.Query(ctx, listServicesByProductTypeDesc,
		arg.ProductTypeID,
		arg.SortBy,
		arg.RequestedPage,
		arg.RequestedPageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Service
	for rows.Next() {
		var i Service
		if err := rows.Scan(
			&i.ID,
			&i.Created,
			&i.Modified,
			&i.Deleted,
			&i.OperatorID,
			&i.ProductTypeID,
			&i.Name,
			&i.SubServiceName,
			&i.StartLocationID,
			&i.EndLocationID,
			&i.StartStationID,
			&i.EndStationID,
			&i.Logo,
			&i.BannerImage,
			&i.ExcludedDates,
			&i.SoldOutDates,
			&i.IsPopular,
			&i.WithPass,
			&i.IsTour,
			&i.TourName,
			&i.Description,
			&i.DayExcursion,
			&i.MultiService,
			&i.ExcursionText,
			&i.ServiceCode,
			&i.MetaTitle,
			&i.MetaContent,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listServicesDesc = `-- name: ListServicesDesc :many
SELECT id, created, modified, deleted, operator_id, product_type_id, name, sub_service_name, start_location_id, end_location_id, start_station_id, end_station_id, logo, banner_image, excluded_dates, sold_out_dates, is_popular, with_pass, is_tour, tour_name, description, day_excursion, multi_service, excursion_text, service_code, meta_title, meta_content, is_active FROM service
WHERE deleted > now() AT TIME ZONE 'UTC'
ORDER BY $1::text DESC
OFFSET ($2::int - 1) * $3::int
    FETCH NEXT $3 ROWS ONLY
`

type ListServicesDescParams struct {
	SortBy            string `db:"sort_by" json:"sortBy"`
	RequestedPage     int32  `db:"requested_page" json:"requestedPage"`
	RequestedPageSize int32  `db:"requested_page_size" json:"requestedPageSize"`
}

func (q *Queries) ListServicesDesc(ctx context.Context, arg ListServicesDescParams) ([]Service, error) {
	rows, err := q.db.Query(ctx, listServicesDesc, arg.SortBy, arg.RequestedPage, arg.RequestedPageSize)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Service
	for rows.Next() {
		var i Service
		if err := rows.Scan(
			&i.ID,
			&i.Created,
			&i.Modified,
			&i.Deleted,
			&i.OperatorID,
			&i.ProductTypeID,
			&i.Name,
			&i.SubServiceName,
			&i.StartLocationID,
			&i.EndLocationID,
			&i.StartStationID,
			&i.EndStationID,
			&i.Logo,
			&i.BannerImage,
			&i.ExcludedDates,
			&i.SoldOutDates,
			&i.IsPopular,
			&i.WithPass,
			&i.IsTour,
			&i.TourName,
			&i.Description,
			&i.DayExcursion,
			&i.MultiService,
			&i.ExcursionText,
			&i.ServiceCode,
			&i.MetaTitle,
			&i.MetaContent,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchServicesAsc = `-- name: SearchServicesAsc :many
SELECT id, created, modified, deleted, operator_id, product_type_id, name, sub_service_name, start_location_id, end_location_id, start_station_id, end_station_id, logo, banner_image, excluded_dates, sold_out_dates, is_popular, with_pass, is_tour, tour_name, description, day_excursion, multi_service, excursion_text, service_code, meta_title, meta_content, is_active FROM service
WHERE deleted > now() AT TIME ZONE 'UTC'
  AND name ILIKE '%' || $1 || '%'
   OR sub_service_name ILIKE '%' || $1 || '%'
   OR description ILIKE '%' || $1 || '%'
   OR tour_name ILIKE '%' || $1 || '%'
   OR service_code ILIKE '%' || $1 || '%'
   OR meta_title ILIKE '%' || $1 || '%'
   OR meta_content ILIKE '%' || $1 || '%'
   OR excursion_text ILIKE '%' || $1 || '%'
ORDER BY $2::text
OFFSET ($3::int - 1) * $4::int
    FETCH NEXT $4 ROWS ONLY
`

type SearchServicesAscParams struct {
	Search            pgtype.Text `db:"search" json:"search"`
	SortBy            string      `db:"sort_by" json:"sortBy"`
	RequestedPage     int32       `db:"requested_page" json:"requestedPage"`
	RequestedPageSize int32       `db:"requested_page_size" json:"requestedPageSize"`
}

func (q *Queries) SearchServicesAsc(ctx context.Context, arg SearchServicesAscParams) ([]Service, error) {
	rows, err := q.db.Query(ctx, searchServicesAsc,
		arg.Search,
		arg.SortBy,
		arg.RequestedPage,
		arg.RequestedPageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Service
	for rows.Next() {
		var i Service
		if err := rows.Scan(
			&i.ID,
			&i.Created,
			&i.Modified,
			&i.Deleted,
			&i.OperatorID,
			&i.ProductTypeID,
			&i.Name,
			&i.SubServiceName,
			&i.StartLocationID,
			&i.EndLocationID,
			&i.StartStationID,
			&i.EndStationID,
			&i.Logo,
			&i.BannerImage,
			&i.ExcludedDates,
			&i.SoldOutDates,
			&i.IsPopular,
			&i.WithPass,
			&i.IsTour,
			&i.TourName,
			&i.Description,
			&i.DayExcursion,
			&i.MultiService,
			&i.ExcursionText,
			&i.ServiceCode,
			&i.MetaTitle,
			&i.MetaContent,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchServicesByOperatorIdAsc = `-- name: SearchServicesByOperatorIdAsc :many
SELECT id, created, modified, deleted, operator_id, product_type_id, name, sub_service_name, start_location_id, end_location_id, start_station_id, end_station_id, logo, banner_image, excluded_dates, sold_out_dates, is_popular, with_pass, is_tour, tour_name, description, day_excursion, multi_service, excursion_text, service_code, meta_title, meta_content, is_active FROM service
WHERE deleted > now() AT TIME ZONE 'UTC'
  AND operator_id = $1
  AND name ILIKE '%' || $2 || '%'
   OR sub_service_name ILIKE '%' || $2 || '%'
   OR description ILIKE '%' || $2 || '%'
   OR tour_name ILIKE '%' || $2 || '%'
   OR service_code ILIKE '%' || $2 || '%'
   OR meta_title ILIKE '%' || $2 || '%'
   OR meta_content ILIKE '%' || $2 || '%'
   OR excursion_text ILIKE '%' || $2 || '%'
ORDER BY $3::text
OFFSET ($4::int - 1) * $5::int
    FETCH NEXT $5 ROWS ONLY
`

type SearchServicesByOperatorIdAscParams struct {
	OperatorID        pgtype.UUID `db:"operator_id" json:"operatorId"`
	Search            pgtype.Text `db:"search" json:"search"`
	SortBy            string      `db:"sort_by" json:"sortBy"`
	RequestedPage     int32       `db:"requested_page" json:"requestedPage"`
	RequestedPageSize int32       `db:"requested_page_size" json:"requestedPageSize"`
}

func (q *Queries) SearchServicesByOperatorIdAsc(ctx context.Context, arg SearchServicesByOperatorIdAscParams) ([]Service, error) {
	rows, err := q.db.Query(ctx, searchServicesByOperatorIdAsc,
		arg.OperatorID,
		arg.Search,
		arg.SortBy,
		arg.RequestedPage,
		arg.RequestedPageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Service
	for rows.Next() {
		var i Service
		if err := rows.Scan(
			&i.ID,
			&i.Created,
			&i.Modified,
			&i.Deleted,
			&i.OperatorID,
			&i.ProductTypeID,
			&i.Name,
			&i.SubServiceName,
			&i.StartLocationID,
			&i.EndLocationID,
			&i.StartStationID,
			&i.EndStationID,
			&i.Logo,
			&i.BannerImage,
			&i.ExcludedDates,
			&i.SoldOutDates,
			&i.IsPopular,
			&i.WithPass,
			&i.IsTour,
			&i.TourName,
			&i.Description,
			&i.DayExcursion,
			&i.MultiService,
			&i.ExcursionText,
			&i.ServiceCode,
			&i.MetaTitle,
			&i.MetaContent,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchServicesByOperatorIdCount = `-- name: SearchServicesByOperatorIdCount :one
SELECT
    COUNT(id)
FROM service
WHERE deleted > now() AT TIME ZONE 'UTC'
  AND operator_id = $1
  AND name ILIKE '%' || $2 || '%'
   OR sub_service_name ILIKE '%' || $2 || '%'
   OR description ILIKE '%' || $2 || '%'
   OR tour_name ILIKE '%' || $2 || '%'
   OR service_code ILIKE '%' || $2 || '%'
   OR meta_title ILIKE '%' || $2 || '%'
   OR meta_content ILIKE '%' || $2 || '%'
   OR excursion_text ILIKE '%' || $2 || '%'
`

type SearchServicesByOperatorIdCountParams struct {
	OperatorID pgtype.UUID `db:"operator_id" json:"operatorId"`
	Search     pgtype.Text `db:"search" json:"search"`
}

func (q *Queries) SearchServicesByOperatorIdCount(ctx context.Context, arg SearchServicesByOperatorIdCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, searchServicesByOperatorIdCount, arg.OperatorID, arg.Search)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const searchServicesByOperatorIdDesc = `-- name: SearchServicesByOperatorIdDesc :many
SELECT id, created, modified, deleted, operator_id, product_type_id, name, sub_service_name, start_location_id, end_location_id, start_station_id, end_station_id, logo, banner_image, excluded_dates, sold_out_dates, is_popular, with_pass, is_tour, tour_name, description, day_excursion, multi_service, excursion_text, service_code, meta_title, meta_content, is_active FROM service
WHERE deleted > now() AT TIME ZONE 'UTC'
  AND operator_id = $1
  AND name ILIKE '%' || $2 || '%'
   OR sub_service_name ILIKE '%' || $2 || '%'
   OR description ILIKE '%' || $2 || '%'
   OR tour_name ILIKE '%' || $2 || '%'
   OR service_code ILIKE '%' || $2 || '%'
   OR meta_title ILIKE '%' || $2 || '%'
   OR meta_content ILIKE '%' || $2 || '%'
   OR excursion_text ILIKE '%' || $2 || '%'
ORDER BY $3::text DESC
OFFSET ($4::int - 1) * $5::int
    FETCH NEXT $5 ROWS ONLY
`

type SearchServicesByOperatorIdDescParams struct {
	OperatorID        pgtype.UUID `db:"operator_id" json:"operatorId"`
	Search            pgtype.Text `db:"search" json:"search"`
	SortBy            string      `db:"sort_by" json:"sortBy"`
	RequestedPage     int32       `db:"requested_page" json:"requestedPage"`
	RequestedPageSize int32       `db:"requested_page_size" json:"requestedPageSize"`
}

func (q *Queries) SearchServicesByOperatorIdDesc(ctx context.Context, arg SearchServicesByOperatorIdDescParams) ([]Service, error) {
	rows, err := q.db.Query(ctx, searchServicesByOperatorIdDesc,
		arg.OperatorID,
		arg.Search,
		arg.SortBy,
		arg.RequestedPage,
		arg.RequestedPageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Service
	for rows.Next() {
		var i Service
		if err := rows.Scan(
			&i.ID,
			&i.Created,
			&i.Modified,
			&i.Deleted,
			&i.OperatorID,
			&i.ProductTypeID,
			&i.Name,
			&i.SubServiceName,
			&i.StartLocationID,
			&i.EndLocationID,
			&i.StartStationID,
			&i.EndStationID,
			&i.Logo,
			&i.BannerImage,
			&i.ExcludedDates,
			&i.SoldOutDates,
			&i.IsPopular,
			&i.WithPass,
			&i.IsTour,
			&i.TourName,
			&i.Description,
			&i.DayExcursion,
			&i.MultiService,
			&i.ExcursionText,
			&i.ServiceCode,
			&i.MetaTitle,
			&i.MetaContent,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchServicesByProductTypeAsc = `-- name: SearchServicesByProductTypeAsc :many
SELECT id, created, modified, deleted, operator_id, product_type_id, name, sub_service_name, start_location_id, end_location_id, start_station_id, end_station_id, logo, banner_image, excluded_dates, sold_out_dates, is_popular, with_pass, is_tour, tour_name, description, day_excursion, multi_service, excursion_text, service_code, meta_title, meta_content, is_active FROM service
WHERE deleted > now() AT TIME ZONE 'UTC'
  AND product_type_id = $1
  AND name ILIKE '%' || $2 || '%'
   OR sub_service_name ILIKE '%' || $2 || '%'
   OR description ILIKE '%' || $2 || '%'
   OR tour_name ILIKE '%' || $2 || '%'
   OR service_code ILIKE '%' || $2 || '%'
   OR meta_title ILIKE '%' || $2 || '%'
   OR meta_content ILIKE '%' || $2 || '%'
   OR excursion_text ILIKE '%' || $2 || '%'
ORDER BY $3::text
OFFSET ($4::int - 1) * $5::int
    FETCH NEXT $5 ROWS ONLY
`

type SearchServicesByProductTypeAscParams struct {
	ProductTypeID     pgtype.UUID `db:"product_type_id" json:"productTypeId"`
	Search            pgtype.Text `db:"search" json:"search"`
	SortBy            string      `db:"sort_by" json:"sortBy"`
	RequestedPage     int32       `db:"requested_page" json:"requestedPage"`
	RequestedPageSize int32       `db:"requested_page_size" json:"requestedPageSize"`
}

func (q *Queries) SearchServicesByProductTypeAsc(ctx context.Context, arg SearchServicesByProductTypeAscParams) ([]Service, error) {
	rows, err := q.db.Query(ctx, searchServicesByProductTypeAsc,
		arg.ProductTypeID,
		arg.Search,
		arg.SortBy,
		arg.RequestedPage,
		arg.RequestedPageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Service
	for rows.Next() {
		var i Service
		if err := rows.Scan(
			&i.ID,
			&i.Created,
			&i.Modified,
			&i.Deleted,
			&i.OperatorID,
			&i.ProductTypeID,
			&i.Name,
			&i.SubServiceName,
			&i.StartLocationID,
			&i.EndLocationID,
			&i.StartStationID,
			&i.EndStationID,
			&i.Logo,
			&i.BannerImage,
			&i.ExcludedDates,
			&i.SoldOutDates,
			&i.IsPopular,
			&i.WithPass,
			&i.IsTour,
			&i.TourName,
			&i.Description,
			&i.DayExcursion,
			&i.MultiService,
			&i.ExcursionText,
			&i.ServiceCode,
			&i.MetaTitle,
			&i.MetaContent,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchServicesByProductTypeDesc = `-- name: SearchServicesByProductTypeDesc :many
SELECT id, created, modified, deleted, operator_id, product_type_id, name, sub_service_name, start_location_id, end_location_id, start_station_id, end_station_id, logo, banner_image, excluded_dates, sold_out_dates, is_popular, with_pass, is_tour, tour_name, description, day_excursion, multi_service, excursion_text, service_code, meta_title, meta_content, is_active FROM service
WHERE deleted > now() AT TIME ZONE 'UTC'
  AND product_type_id = $1
  AND name ILIKE '%' || $2 || '%'
    OR sub_service_name ILIKE '%' || $2 || '%'
    OR description ILIKE '%' || $2 || '%'
    OR tour_name ILIKE '%' || $2 || '%'
    OR service_code ILIKE '%' || $2 || '%'
    OR meta_title ILIKE '%' || $2 || '%'
    OR meta_content ILIKE '%' || $2 || '%'
    OR excursion_text ILIKE '%' || $2 || '%'
ORDER BY $3::text DESC
OFFSET ($4::int - 1) * $5::int
    FETCH NEXT $5 ROWS ONLY
`

type SearchServicesByProductTypeDescParams struct {
	ProductTypeID     pgtype.UUID `db:"product_type_id" json:"productTypeId"`
	Search            pgtype.Text `db:"search" json:"search"`
	SortBy            string      `db:"sort_by" json:"sortBy"`
	RequestedPage     int32       `db:"requested_page" json:"requestedPage"`
	RequestedPageSize int32       `db:"requested_page_size" json:"requestedPageSize"`
}

func (q *Queries) SearchServicesByProductTypeDesc(ctx context.Context, arg SearchServicesByProductTypeDescParams) ([]Service, error) {
	rows, err := q.db.Query(ctx, searchServicesByProductTypeDesc,
		arg.ProductTypeID,
		arg.Search,
		arg.SortBy,
		arg.RequestedPage,
		arg.RequestedPageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Service
	for rows.Next() {
		var i Service
		if err := rows.Scan(
			&i.ID,
			&i.Created,
			&i.Modified,
			&i.Deleted,
			&i.OperatorID,
			&i.ProductTypeID,
			&i.Name,
			&i.SubServiceName,
			&i.StartLocationID,
			&i.EndLocationID,
			&i.StartStationID,
			&i.EndStationID,
			&i.Logo,
			&i.BannerImage,
			&i.ExcludedDates,
			&i.SoldOutDates,
			&i.IsPopular,
			&i.WithPass,
			&i.IsTour,
			&i.TourName,
			&i.Description,
			&i.DayExcursion,
			&i.MultiService,
			&i.ExcursionText,
			&i.ServiceCode,
			&i.MetaTitle,
			&i.MetaContent,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchServicesByProductTypeIdCount = `-- name: SearchServicesByProductTypeIdCount :one
SELECT
    COUNT(id)
FROM service
WHERE deleted > now() AT TIME ZONE 'UTC'
  AND product_type_id = $1
  AND name ILIKE '%' || $2 || '%'
   OR sub_service_name ILIKE '%' || $2 || '%'
   OR description ILIKE '%' || $2 || '%'
   OR tour_name ILIKE '%' || $2 || '%'
   OR service_code ILIKE '%' || $2 || '%'
   OR meta_title ILIKE '%' || $2 || '%'
   OR meta_content ILIKE '%' || $2 || '%'
   OR excursion_text ILIKE '%' || $2 || '%'
`

type SearchServicesByProductTypeIdCountParams struct {
	ProductTypeID pgtype.UUID `db:"product_type_id" json:"productTypeId"`
	Search        pgtype.Text `db:"search" json:"search"`
}

func (q *Queries) SearchServicesByProductTypeIdCount(ctx context.Context, arg SearchServicesByProductTypeIdCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, searchServicesByProductTypeIdCount, arg.ProductTypeID, arg.Search)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const searchServicesCount = `-- name: SearchServicesCount :one
SELECT
    COUNT(id)
FROM service
WHERE deleted > now() AT TIME ZONE 'UTC'
  AND name ILIKE '%' || $1 || '%'
   OR sub_service_name ILIKE '%' || $1 || '%'
   OR description ILIKE '%' || $1 || '%'
   OR tour_name ILIKE '%' || $1 || '%'
   OR service_code ILIKE '%' || $1 || '%'
   OR meta_title ILIKE '%' || $1 || '%'
   OR meta_content ILIKE '%' || $1 || '%'
   OR excursion_text ILIKE '%' || $1 || '%'
`

func (q *Queries) SearchServicesCount(ctx context.Context, search pgtype.Text) (int64, error) {
	row := q.db.QueryRow(ctx, searchServicesCount, search)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const searchServicesDesc = `-- name: SearchServicesDesc :many
SELECT id, created, modified, deleted, operator_id, product_type_id, name, sub_service_name, start_location_id, end_location_id, start_station_id, end_station_id, logo, banner_image, excluded_dates, sold_out_dates, is_popular, with_pass, is_tour, tour_name, description, day_excursion, multi_service, excursion_text, service_code, meta_title, meta_content, is_active FROM service
WHERE deleted > now() AT TIME ZONE 'UTC'
  AND name ILIKE '%' || $1 || '%'
   OR sub_service_name ILIKE '%' || $1 || '%'
   OR description ILIKE '%' || $1 || '%'
   OR tour_name ILIKE '%' || $1 || '%'
   OR service_code ILIKE '%' || $1 || '%'
   OR meta_title ILIKE '%' || $1 || '%'
   OR meta_content ILIKE '%' || $1 || '%'
   OR excursion_text ILIKE '%' || $1 || '%'
ORDER BY $2::text DESC
OFFSET ($3::int - 1) * $4::int
    FETCH NEXT $4 ROWS ONLY
`

type SearchServicesDescParams struct {
	Search            pgtype.Text `db:"search" json:"search"`
	SortBy            string      `db:"sort_by" json:"sortBy"`
	RequestedPage     int32       `db:"requested_page" json:"requestedPage"`
	RequestedPageSize int32       `db:"requested_page_size" json:"requestedPageSize"`
}

func (q *Queries) SearchServicesDesc(ctx context.Context, arg SearchServicesDescParams) ([]Service, error) {
	rows, err := q.db.Query(ctx, searchServicesDesc,
		arg.Search,
		arg.SortBy,
		arg.RequestedPage,
		arg.RequestedPageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Service
	for rows.Next() {
		var i Service
		if err := rows.Scan(
			&i.ID,
			&i.Created,
			&i.Modified,
			&i.Deleted,
			&i.OperatorID,
			&i.ProductTypeID,
			&i.Name,
			&i.SubServiceName,
			&i.StartLocationID,
			&i.EndLocationID,
			&i.StartStationID,
			&i.EndStationID,
			&i.Logo,
			&i.BannerImage,
			&i.ExcludedDates,
			&i.SoldOutDates,
			&i.IsPopular,
			&i.WithPass,
			&i.IsTour,
			&i.TourName,
			&i.Description,
			&i.DayExcursion,
			&i.MultiService,
			&i.ExcursionText,
			&i.ServiceCode,
			&i.MetaTitle,
			&i.MetaContent,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateService = `-- name: UpdateService :one
UPDATE service
SET
    modified = now() AT TIME ZONE 'UTC',
    operator_id = $2,
    product_type_id = $3,
    name = $4,
    sub_service_name = $5,
    start_location_id = $6,
    end_location_id = $7,
    start_station_id = $8,
    end_station_id = $9,
    logo = $10,
    banner_image = $11,
    excluded_dates = $12,
    sold_out_dates = $13,
    is_popular = $14,
    with_pass = $15,
    is_tour = $16,
    tour_name = $17,
    description = $18,
    day_excursion = $19,
    multi_service = $20,
    excursion_text = $21,
    service_code = $22,
    meta_title = $23,
    meta_content = $24,
    is_active = $25
WHERE id = $1
RETURNING id, created, modified, deleted, operator_id, product_type_id, name, sub_service_name, start_location_id, end_location_id, start_station_id, end_station_id, logo, banner_image, excluded_dates, sold_out_dates, is_popular, with_pass, is_tour, tour_name, description, day_excursion, multi_service, excursion_text, service_code, meta_title, meta_content, is_active
`

type UpdateServiceParams struct {
	ID              pgtype.UUID          `db:"id" json:"id"`
	OperatorID      pgtype.UUID          `db:"operator_id" json:"operatorId"`
	ProductTypeID   pgtype.UUID          `db:"product_type_id" json:"productTypeId"`
	Name            string               `db:"name" json:"name"`
	SubServiceName  pgtype.Text          `db:"sub_service_name" json:"subServiceName"`
	StartLocationID pgtype.UUID          `db:"start_location_id" json:"startLocationId"`
	EndLocationID   pgtype.UUID          `db:"end_location_id" json:"endLocationId"`
	StartStationID  pgtype.UUID          `db:"start_station_id" json:"startStationId"`
	EndStationID    pgtype.UUID          `db:"end_station_id" json:"endStationId"`
	Logo            pgtype.Text          `db:"logo" json:"logo"`
	BannerImage     pgtype.Text          `db:"banner_image" json:"bannerImage"`
	ExcludedDates   []pgtype.Timestamptz `db:"excluded_dates" json:"excludedDates"`
	SoldOutDates    []pgtype.Timestamptz `db:"sold_out_dates" json:"soldOutDates"`
	IsPopular       bool                 `db:"is_popular" json:"isPopular"`
	WithPass        bool                 `db:"with_pass" json:"withPass"`
	IsTour          bool                 `db:"is_tour" json:"isTour"`
	TourName        pgtype.Text          `db:"tour_name" json:"tourName"`
	Description     pgtype.Text          `db:"description" json:"description"`
	DayExcursion    bool                 `db:"day_excursion" json:"dayExcursion"`
	MultiService    bool                 `db:"multi_service" json:"multiService"`
	ExcursionText   pgtype.Text          `db:"excursion_text" json:"excursionText"`
	ServiceCode     pgtype.Text          `db:"service_code" json:"serviceCode"`
	MetaTitle       pgtype.Text          `db:"meta_title" json:"metaTitle"`
	MetaContent     pgtype.Text          `db:"meta_content" json:"metaContent"`
	IsActive        bool                 `db:"is_active" json:"isActive"`
}

func (q *Queries) UpdateService(ctx context.Context, arg UpdateServiceParams) (Service, error) {
	row := q.db.QueryRow(ctx, updateService,
		arg.ID,
		arg.OperatorID,
		arg.ProductTypeID,
		arg.Name,
		arg.SubServiceName,
		arg.StartLocationID,
		arg.EndLocationID,
		arg.StartStationID,
		arg.EndStationID,
		arg.Logo,
		arg.BannerImage,
		arg.ExcludedDates,
		arg.SoldOutDates,
		arg.IsPopular,
		arg.WithPass,
		arg.IsTour,
		arg.TourName,
		arg.Description,
		arg.DayExcursion,
		arg.MultiService,
		arg.ExcursionText,
		arg.ServiceCode,
		arg.MetaTitle,
		arg.MetaContent,
		arg.IsActive,
	)
	var i Service
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Modified,
		&i.Deleted,
		&i.OperatorID,
		&i.ProductTypeID,
		&i.Name,
		&i.SubServiceName,
		&i.StartLocationID,
		&i.EndLocationID,
		&i.StartStationID,
		&i.EndStationID,
		&i.Logo,
		&i.BannerImage,
		&i.ExcludedDates,
		&i.SoldOutDates,
		&i.IsPopular,
		&i.WithPass,
		&i.IsTour,
		&i.TourName,
		&i.Description,
		&i.DayExcursion,
		&i.MultiService,
		&i.ExcursionText,
		&i.ServiceCode,
		&i.MetaTitle,
		&i.MetaContent,
		&i.IsActive,
	)
	return i, err
}
