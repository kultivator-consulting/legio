// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: product_type.sql

package db_gen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countProductTypes = `-- name: CountProductTypes :one
SELECT
    COUNT(id)
FROM product_type
WHERE deleted > now() AT TIME ZONE 'UTC'
`

func (q *Queries) CountProductTypes(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countProductTypes)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createProductType = `-- name: CreateProductType :one
INSERT INTO product_type (
    id,
    created,
    modified,
    deleted,
    name,
    priority,
    slug,
    terms,
    is_pass_type,
    is_pass_service,
    is_active
) VALUES (
             uuid_generate_v4(),
             now() AT TIME ZONE 'UTC',
             now() AT TIME ZONE 'UTC',
             'infinity'::timestamp AT TIME ZONE 'UTC',
             $1, $2, $3, $4, $5, $6, $7
         )
RETURNING id, created, modified, deleted, name, priority, slug, terms, is_pass_type, is_pass_service, is_active
`

type CreateProductTypeParams struct {
	Name          string `db:"name" json:"name"`
	Priority      int32  `db:"priority" json:"priority"`
	Slug          string `db:"slug" json:"slug"`
	Terms         string `db:"terms" json:"terms"`
	IsPassType    bool   `db:"is_pass_type" json:"isPassType"`
	IsPassService bool   `db:"is_pass_service" json:"isPassService"`
	IsActive      bool   `db:"is_active" json:"isActive"`
}

func (q *Queries) CreateProductType(ctx context.Context, arg CreateProductTypeParams) (ProductType, error) {
	row := q.db.QueryRow(ctx, createProductType,
		arg.Name,
		arg.Priority,
		arg.Slug,
		arg.Terms,
		arg.IsPassType,
		arg.IsPassService,
		arg.IsActive,
	)
	var i ProductType
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Modified,
		&i.Deleted,
		&i.Name,
		&i.Priority,
		&i.Slug,
		&i.Terms,
		&i.IsPassType,
		&i.IsPassService,
		&i.IsActive,
	)
	return i, err
}

const createProductTypeAndReturnId = `-- name: CreateProductTypeAndReturnId :one
INSERT INTO product_type (
    id,
    created,
    modified,
    deleted,
    name,
    priority,
    slug,
    terms,
    is_pass_type,
    is_pass_service,
    is_active
) VALUES (
             uuid_generate_v4(),
             now() AT TIME ZONE 'UTC',
             now() AT TIME ZONE 'UTC',
             'infinity'::timestamp AT TIME ZONE 'UTC',
             $1, $2, $3, $4, $5, $6, $7
         )
RETURNING id
`

type CreateProductTypeAndReturnIdParams struct {
	Name          string `db:"name" json:"name"`
	Priority      int32  `db:"priority" json:"priority"`
	Slug          string `db:"slug" json:"slug"`
	Terms         string `db:"terms" json:"terms"`
	IsPassType    bool   `db:"is_pass_type" json:"isPassType"`
	IsPassService bool   `db:"is_pass_service" json:"isPassService"`
	IsActive      bool   `db:"is_active" json:"isActive"`
}

func (q *Queries) CreateProductTypeAndReturnId(ctx context.Context, arg CreateProductTypeAndReturnIdParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, createProductTypeAndReturnId,
		arg.Name,
		arg.Priority,
		arg.Slug,
		arg.Terms,
		arg.IsPassType,
		arg.IsPassService,
		arg.IsActive,
	)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const deleteProductType = `-- name: DeleteProductType :exec
UPDATE product_type
SET
    deleted = now() AT TIME ZONE 'UTC'
WHERE id = $1
`

func (q *Queries) DeleteProductType(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteProductType, id)
	return err
}

const getProductType = `-- name: GetProductType :one
SELECT id, created, modified, deleted, name, priority, slug, terms, is_pass_type, is_pass_service, is_active FROM product_type
WHERE id = $1
  AND deleted > now() AT TIME ZONE 'UTC'
LIMIT 1
`

func (q *Queries) GetProductType(ctx context.Context, id pgtype.UUID) (ProductType, error) {
	row := q.db.QueryRow(ctx, getProductType, id)
	var i ProductType
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Modified,
		&i.Deleted,
		&i.Name,
		&i.Priority,
		&i.Slug,
		&i.Terms,
		&i.IsPassType,
		&i.IsPassService,
		&i.IsActive,
	)
	return i, err
}

const getProductTypeById = `-- name: GetProductTypeById :one
SELECT id, created, modified, deleted, name, priority, slug, terms, is_pass_type, is_pass_service, is_active FROM product_type
WHERE id = $1
  AND deleted > now() AT TIME ZONE 'UTC'
LIMIT 1
`

func (q *Queries) GetProductTypeById(ctx context.Context, id pgtype.UUID) (ProductType, error) {
	row := q.db.QueryRow(ctx, getProductTypeById, id)
	var i ProductType
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Modified,
		&i.Deleted,
		&i.Name,
		&i.Priority,
		&i.Slug,
		&i.Terms,
		&i.IsPassType,
		&i.IsPassService,
		&i.IsActive,
	)
	return i, err
}

const getProductTypeByName = `-- name: GetProductTypeByName :one
SELECT id, created, modified, deleted, name, priority, slug, terms, is_pass_type, is_pass_service, is_active FROM product_type
WHERE name = $1
  AND deleted > now() AT TIME ZONE 'UTC'
  AND is_active = TRUE
LIMIT 1
`

func (q *Queries) GetProductTypeByName(ctx context.Context, name string) (ProductType, error) {
	row := q.db.QueryRow(ctx, getProductTypeByName, name)
	var i ProductType
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Modified,
		&i.Deleted,
		&i.Name,
		&i.Priority,
		&i.Slug,
		&i.Terms,
		&i.IsPassType,
		&i.IsPassService,
		&i.IsActive,
	)
	return i, err
}

const getProductTypeBySlug = `-- name: GetProductTypeBySlug :one
SELECT id, created, modified, deleted, name, priority, slug, terms, is_pass_type, is_pass_service, is_active FROM product_type
WHERE slug = $1
  AND deleted > now() AT TIME ZONE 'UTC'
  AND is_active = TRUE
LIMIT 1
`

func (q *Queries) GetProductTypeBySlug(ctx context.Context, slug string) (ProductType, error) {
	row := q.db.QueryRow(ctx, getProductTypeBySlug, slug)
	var i ProductType
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Modified,
		&i.Deleted,
		&i.Name,
		&i.Priority,
		&i.Slug,
		&i.Terms,
		&i.IsPassType,
		&i.IsPassService,
		&i.IsActive,
	)
	return i, err
}

const listProductTypesAsc = `-- name: ListProductTypesAsc :many
SELECT id, created, modified, deleted, name, priority, slug, terms, is_pass_type, is_pass_service, is_active FROM product_type
WHERE deleted > now() AT TIME ZONE 'UTC'
ORDER BY $1::text
OFFSET ($2::int - 1) * $3::int
    FETCH NEXT $3 ROWS ONLY
`

type ListProductTypesAscParams struct {
	SortBy            string `db:"sort_by" json:"sortBy"`
	RequestedPage     int32  `db:"requested_page" json:"requestedPage"`
	RequestedPageSize int32  `db:"requested_page_size" json:"requestedPageSize"`
}

func (q *Queries) ListProductTypesAsc(ctx context.Context, arg ListProductTypesAscParams) ([]ProductType, error) {
	rows, err := q.db.Query(ctx, listProductTypesAsc, arg.SortBy, arg.RequestedPage, arg.RequestedPageSize)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProductType
	for rows.Next() {
		var i ProductType
		if err := rows.Scan(
			&i.ID,
			&i.Created,
			&i.Modified,
			&i.Deleted,
			&i.Name,
			&i.Priority,
			&i.Slug,
			&i.Terms,
			&i.IsPassType,
			&i.IsPassService,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProductTypesByPassService = `-- name: ListProductTypesByPassService :many
SELECT id, created, modified, deleted, name, priority, slug, terms, is_pass_type, is_pass_service, is_active FROM product_type
WHERE is_pass_service = TRUE
  AND deleted > now() AT TIME ZONE 'UTC'
`

func (q *Queries) ListProductTypesByPassService(ctx context.Context) ([]ProductType, error) {
	rows, err := q.db.Query(ctx, listProductTypesByPassService)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProductType
	for rows.Next() {
		var i ProductType
		if err := rows.Scan(
			&i.ID,
			&i.Created,
			&i.Modified,
			&i.Deleted,
			&i.Name,
			&i.Priority,
			&i.Slug,
			&i.Terms,
			&i.IsPassType,
			&i.IsPassService,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProductTypesByPassType = `-- name: ListProductTypesByPassType :many
SELECT id, created, modified, deleted, name, priority, slug, terms, is_pass_type, is_pass_service, is_active FROM product_type
WHERE is_pass_type = TRUE
  AND deleted > now() AT TIME ZONE 'UTC'
`

func (q *Queries) ListProductTypesByPassType(ctx context.Context) ([]ProductType, error) {
	rows, err := q.db.Query(ctx, listProductTypesByPassType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProductType
	for rows.Next() {
		var i ProductType
		if err := rows.Scan(
			&i.ID,
			&i.Created,
			&i.Modified,
			&i.Deleted,
			&i.Name,
			&i.Priority,
			&i.Slug,
			&i.Terms,
			&i.IsPassType,
			&i.IsPassService,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProductTypesDesc = `-- name: ListProductTypesDesc :many
SELECT id, created, modified, deleted, name, priority, slug, terms, is_pass_type, is_pass_service, is_active FROM product_type
WHERE deleted > now() AT TIME ZONE 'UTC'
ORDER BY $1::text DESC
OFFSET ($2::int - 1) * $3::int
    FETCH NEXT $3 ROWS ONLY
`

type ListProductTypesDescParams struct {
	SortBy            string `db:"sort_by" json:"sortBy"`
	RequestedPage     int32  `db:"requested_page" json:"requestedPage"`
	RequestedPageSize int32  `db:"requested_page_size" json:"requestedPageSize"`
}

func (q *Queries) ListProductTypesDesc(ctx context.Context, arg ListProductTypesDescParams) ([]ProductType, error) {
	rows, err := q.db.Query(ctx, listProductTypesDesc, arg.SortBy, arg.RequestedPage, arg.RequestedPageSize)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProductType
	for rows.Next() {
		var i ProductType
		if err := rows.Scan(
			&i.ID,
			&i.Created,
			&i.Modified,
			&i.Deleted,
			&i.Name,
			&i.Priority,
			&i.Slug,
			&i.Terms,
			&i.IsPassType,
			&i.IsPassService,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProductType = `-- name: UpdateProductType :one
UPDATE product_type
SET
    modified = now() AT TIME ZONE 'UTC',
    name = $2,
    priority = $3,
    slug = $4,
    terms = $5,
    is_pass_type = $6,
    is_pass_service = $7,
    is_active = $8
WHERE id = $1
RETURNING id, created, modified, deleted, name, priority, slug, terms, is_pass_type, is_pass_service, is_active
`

type UpdateProductTypeParams struct {
	ID            pgtype.UUID `db:"id" json:"id"`
	Name          string      `db:"name" json:"name"`
	Priority      int32       `db:"priority" json:"priority"`
	Slug          string      `db:"slug" json:"slug"`
	Terms         string      `db:"terms" json:"terms"`
	IsPassType    bool        `db:"is_pass_type" json:"isPassType"`
	IsPassService bool        `db:"is_pass_service" json:"isPassService"`
	IsActive      bool        `db:"is_active" json:"isActive"`
}

func (q *Queries) UpdateProductType(ctx context.Context, arg UpdateProductTypeParams) (ProductType, error) {
	row := q.db.QueryRow(ctx, updateProductType,
		arg.ID,
		arg.Name,
		arg.Priority,
		arg.Slug,
		arg.Terms,
		arg.IsPassType,
		arg.IsPassService,
		arg.IsActive,
	)
	var i ProductType
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Modified,
		&i.Deleted,
		&i.Name,
		&i.Priority,
		&i.Slug,
		&i.Terms,
		&i.IsPassType,
		&i.IsPassService,
		&i.IsActive,
	)
	return i, err
}
