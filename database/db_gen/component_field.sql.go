// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: component_field.sql

package db_gen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createComponentFieldAndReturnId = `-- name: CreateComponentFieldAndReturnId :one
INSERT INTO component_field (
    id,
    created,
    modified,
    deleted,
    component_id,
    name,
    description,
    data_type,
    editor_type,
    validation,
    default_value,
    is_active
) VALUES (
             uuid_generate_v4(),
             now() AT TIME ZONE 'UTC',
             now() AT TIME ZONE 'UTC',
             'infinity'::timestamp AT TIME ZONE 'UTC',
             $1, $2, $3, $4, $5, $6, $7, $8
         )
RETURNING id
`

type CreateComponentFieldAndReturnIdParams struct {
	ComponentID  pgtype.UUID `db:"component_id" json:"componentId"`
	Name         string      `db:"name" json:"name"`
	Description  string      `db:"description" json:"description"`
	DataType     string      `db:"data_type" json:"dataType"`
	EditorType   string      `db:"editor_type" json:"editorType"`
	Validation   string      `db:"validation" json:"validation"`
	DefaultValue string      `db:"default_value" json:"defaultValue"`
	IsActive     bool        `db:"is_active" json:"isActive"`
}

func (q *Queries) CreateComponentFieldAndReturnId(ctx context.Context, arg CreateComponentFieldAndReturnIdParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, createComponentFieldAndReturnId,
		arg.ComponentID,
		arg.Name,
		arg.Description,
		arg.DataType,
		arg.EditorType,
		arg.Validation,
		arg.DefaultValue,
		arg.IsActive,
	)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const deleteComponentFieldByComponentId = `-- name: DeleteComponentFieldByComponentId :exec
UPDATE component_field
SET
    deleted = now() AT TIME ZONE 'UTC'
WHERE component_id = $1
`

func (q *Queries) DeleteComponentFieldByComponentId(ctx context.Context, componentID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteComponentFieldByComponentId, componentID)
	return err
}

const deleteComponentFieldByIdAndComponentId = `-- name: DeleteComponentFieldByIdAndComponentId :exec
UPDATE component_field
SET
    deleted = now() AT TIME ZONE 'UTC'
WHERE id = $1
    AND component_id = $2
`

type DeleteComponentFieldByIdAndComponentIdParams struct {
	ID          pgtype.UUID `db:"id" json:"id"`
	ComponentID pgtype.UUID `db:"component_id" json:"componentId"`
}

func (q *Queries) DeleteComponentFieldByIdAndComponentId(ctx context.Context, arg DeleteComponentFieldByIdAndComponentIdParams) error {
	_, err := q.db.Exec(ctx, deleteComponentFieldByIdAndComponentId, arg.ID, arg.ComponentID)
	return err
}

const getComponentFieldById = `-- name: GetComponentFieldById :one
SELECT id, created, modified, deleted, component_id, name, description, data_type, editor_type, validation, default_value, is_active FROM component_field
WHERE id = $1
  AND deleted > now() AT TIME ZONE 'UTC'
LIMIT 1
`

func (q *Queries) GetComponentFieldById(ctx context.Context, id pgtype.UUID) (ComponentField, error) {
	row := q.db.QueryRow(ctx, getComponentFieldById, id)
	var i ComponentField
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Modified,
		&i.Deleted,
		&i.ComponentID,
		&i.Name,
		&i.Description,
		&i.DataType,
		&i.EditorType,
		&i.Validation,
		&i.DefaultValue,
		&i.IsActive,
	)
	return i, err
}

const listComponentFieldByComponentId = `-- name: ListComponentFieldByComponentId :many
SELECT id, created, modified, deleted, component_id, name, description, data_type, editor_type, validation, default_value, is_active FROM component_field
WHERE component_id = $1
  AND deleted > now() AT TIME ZONE 'UTC'
`

func (q *Queries) ListComponentFieldByComponentId(ctx context.Context, componentID pgtype.UUID) ([]ComponentField, error) {
	rows, err := q.db.Query(ctx, listComponentFieldByComponentId, componentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ComponentField
	for rows.Next() {
		var i ComponentField
		if err := rows.Scan(
			&i.ID,
			&i.Created,
			&i.Modified,
			&i.Deleted,
			&i.ComponentID,
			&i.Name,
			&i.Description,
			&i.DataType,
			&i.EditorType,
			&i.Validation,
			&i.DefaultValue,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listComponentFieldByComponentIdAndName = `-- name: ListComponentFieldByComponentIdAndName :many
SELECT id, created, modified, deleted, component_id, name, description, data_type, editor_type, validation, default_value, is_active FROM component_field
WHERE component_id = $1
  AND name = $2
  AND deleted > now() AT TIME ZONE 'UTC'
`

type ListComponentFieldByComponentIdAndNameParams struct {
	ComponentID pgtype.UUID `db:"component_id" json:"componentId"`
	Name        string      `db:"name" json:"name"`
}

func (q *Queries) ListComponentFieldByComponentIdAndName(ctx context.Context, arg ListComponentFieldByComponentIdAndNameParams) ([]ComponentField, error) {
	rows, err := q.db.Query(ctx, listComponentFieldByComponentIdAndName, arg.ComponentID, arg.Name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ComponentField
	for rows.Next() {
		var i ComponentField
		if err := rows.Scan(
			&i.ID,
			&i.Created,
			&i.Modified,
			&i.Deleted,
			&i.ComponentID,
			&i.Name,
			&i.Description,
			&i.DataType,
			&i.EditorType,
			&i.Validation,
			&i.DefaultValue,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateComponentField = `-- name: UpdateComponentField :one
UPDATE component_field
SET
    modified = now() AT TIME ZONE 'UTC',
    component_id = $2,
    name = $3,
    description = $4,
    data_type = $5,
    editor_type = $6,
    validation = $7,
    default_value = $8,
    is_active = $9
WHERE id = $1
RETURNING id, created, modified, deleted, component_id, name, description, data_type, editor_type, validation, default_value, is_active
`

type UpdateComponentFieldParams struct {
	ID           pgtype.UUID `db:"id" json:"id"`
	ComponentID  pgtype.UUID `db:"component_id" json:"componentId"`
	Name         string      `db:"name" json:"name"`
	Description  string      `db:"description" json:"description"`
	DataType     string      `db:"data_type" json:"dataType"`
	EditorType   string      `db:"editor_type" json:"editorType"`
	Validation   string      `db:"validation" json:"validation"`
	DefaultValue string      `db:"default_value" json:"defaultValue"`
	IsActive     bool        `db:"is_active" json:"isActive"`
}

func (q *Queries) UpdateComponentField(ctx context.Context, arg UpdateComponentFieldParams) (ComponentField, error) {
	row := q.db.QueryRow(ctx, updateComponentField,
		arg.ID,
		arg.ComponentID,
		arg.Name,
		arg.Description,
		arg.DataType,
		arg.EditorType,
		arg.Validation,
		arg.DefaultValue,
		arg.IsActive,
	)
	var i ComponentField
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Modified,
		&i.Deleted,
		&i.ComponentID,
		&i.Name,
		&i.Description,
		&i.DataType,
		&i.EditorType,
		&i.Validation,
		&i.DefaultValue,
		&i.IsActive,
	)
	return i, err
}
