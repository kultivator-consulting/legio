// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: pass_service.sql

package db_gen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countPassServices = `-- name: CountPassServices :one
SELECT
    COUNT(id)
FROM pass_service
WHERE pass_id = $1
`

func (q *Queries) CountPassServices(ctx context.Context, passID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countPassServices, passID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createPassService = `-- name: CreatePassService :one
INSERT INTO pass_service (
    id,
    created,
    modified,
    pass_id,
    name,
    duration,
    duration_type
) VALUES (
             uuid_generate_v4(),
             now() AT TIME ZONE 'UTC',
             now() AT TIME ZONE 'UTC',
             $1, $2, $3, $4
         )
RETURNING id, created, modified, pass_id, name, duration, duration_type
`

type CreatePassServiceParams struct {
	PassID       pgtype.UUID `db:"pass_id" json:"passId"`
	Name         string      `db:"name" json:"name"`
	Duration     int32       `db:"duration" json:"duration"`
	DurationType string      `db:"duration_type" json:"durationType"`
}

func (q *Queries) CreatePassService(ctx context.Context, arg CreatePassServiceParams) (PassService, error) {
	row := q.db.QueryRow(ctx, createPassService,
		arg.PassID,
		arg.Name,
		arg.Duration,
		arg.DurationType,
	)
	var i PassService
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Modified,
		&i.PassID,
		&i.Name,
		&i.Duration,
		&i.DurationType,
	)
	return i, err
}

const deletePassService = `-- name: DeletePassService :exec
DELETE FROM pass_service
WHERE id = $1
`

func (q *Queries) DeletePassService(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deletePassService, id)
	return err
}

const getPassServiceById = `-- name: GetPassServiceById :one
SELECT id, created, modified, pass_id, name, duration, duration_type FROM pass_service
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetPassServiceById(ctx context.Context, id pgtype.UUID) (PassService, error) {
	row := q.db.QueryRow(ctx, getPassServiceById, id)
	var i PassService
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Modified,
		&i.PassID,
		&i.Name,
		&i.Duration,
		&i.DurationType,
	)
	return i, err
}

const getPassServiceByName = `-- name: GetPassServiceByName :one
SELECT id, created, modified, pass_id, name, duration, duration_type FROM pass_service
WHERE name = $1
LIMIT 1
`

func (q *Queries) GetPassServiceByName(ctx context.Context, name string) (PassService, error) {
	row := q.db.QueryRow(ctx, getPassServiceByName, name)
	var i PassService
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Modified,
		&i.PassID,
		&i.Name,
		&i.Duration,
		&i.DurationType,
	)
	return i, err
}

const listPassServicesByPassId = `-- name: ListPassServicesByPassId :many
SELECT id, created, modified, pass_id, name, duration, duration_type FROM pass_service
WHERE pass_id = $1
`

func (q *Queries) ListPassServicesByPassId(ctx context.Context, passID pgtype.UUID) ([]PassService, error) {
	rows, err := q.db.Query(ctx, listPassServicesByPassId, passID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PassService
	for rows.Next() {
		var i PassService
		if err := rows.Scan(
			&i.ID,
			&i.Created,
			&i.Modified,
			&i.PassID,
			&i.Name,
			&i.Duration,
			&i.DurationType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePassService = `-- name: UpdatePassService :one
UPDATE pass_service
SET
    modified = now() AT TIME ZONE 'UTC',
    pass_id = $2,
    name = $3,
    duration = $4,
    duration_type = $5
WHERE id = $1
RETURNING id, created, modified, pass_id, name, duration, duration_type
`

type UpdatePassServiceParams struct {
	ID           pgtype.UUID `db:"id" json:"id"`
	PassID       pgtype.UUID `db:"pass_id" json:"passId"`
	Name         string      `db:"name" json:"name"`
	Duration     int32       `db:"duration" json:"duration"`
	DurationType string      `db:"duration_type" json:"durationType"`
}

func (q *Queries) UpdatePassService(ctx context.Context, arg UpdatePassServiceParams) (PassService, error) {
	row := q.db.QueryRow(ctx, updatePassService,
		arg.ID,
		arg.PassID,
		arg.Name,
		arg.Duration,
		arg.DurationType,
	)
	var i PassService
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Modified,
		&i.PassID,
		&i.Name,
		&i.Duration,
		&i.DurationType,
	)
	return i, err
}

const upsertPassService = `-- name: UpsertPassService :one
INSERT INTO pass_service (
    id,
    created,
    modified,
    pass_id,
    name,
    duration,
    duration_type
) VALUES (
             coalesce(nullif($5, uuid_nil()), uuid_generate_v4()),
             now() AT TIME ZONE 'UTC',
             now() AT TIME ZONE 'UTC',
             $1, $2, $3, $4
         )
ON CONFLICT (id) DO UPDATE
    SET
        modified = now() AT TIME ZONE 'UTC',
        pass_id = $1,
        name = $2,
        duration = $3,
        duration_type = $4
RETURNING id, created, modified, pass_id, name, duration, duration_type
`

type UpsertPassServiceParams struct {
	PassID       pgtype.UUID `db:"pass_id" json:"passId"`
	Name         string      `db:"name" json:"name"`
	Duration     int32       `db:"duration" json:"duration"`
	DurationType string      `db:"duration_type" json:"durationType"`
	ID           interface{} `db:"id" json:"id"`
}

func (q *Queries) UpsertPassService(ctx context.Context, arg UpsertPassServiceParams) (PassService, error) {
	row := q.db.QueryRow(ctx, upsertPassService,
		arg.PassID,
		arg.Name,
		arg.Duration,
		arg.DurationType,
		arg.ID,
	)
	var i PassService
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Modified,
		&i.PassID,
		&i.Name,
		&i.Duration,
		&i.DurationType,
	)
	return i, err
}
