// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: session.sql

package db_gen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countSessions = `-- name: CountSessions :one
SELECT
    COUNT(id)
FROM session
WHERE deleted > now() AT TIME ZONE 'UTC'
`

func (q *Queries) CountSessions(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countSessions)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createSession = `-- name: CreateSession :one
INSERT INTO session (
    id,
    created,
    modified,
    deleted,
    account_id,
    client_id,
    client_agent,
    client_ip,
    client_bundle_id,
    access_token,
    refresh_token,
    access_token_expiry,
    refresh_token_expiry,
    is_device_app
) VALUES (
             uuid_generate_v4(),
             now() AT TIME ZONE 'UTC',
             now() AT TIME ZONE 'UTC',
             'infinity'::timestamp AT TIME ZONE 'UTC',
             $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
         )
RETURNING id, created, modified, deleted, account_id, client_id, client_agent, client_ip, client_bundle_id, access_token, refresh_token, access_token_expiry, refresh_token_expiry, is_device_app
`

type CreateSessionParams struct {
	AccountID          pgtype.UUID        `db:"account_id" json:"accountId"`
	ClientID           pgtype.UUID        `db:"client_id" json:"clientId"`
	ClientAgent        string             `db:"client_agent" json:"clientAgent"`
	ClientIp           string             `db:"client_ip" json:"clientIp"`
	ClientBundleID     pgtype.Text        `db:"client_bundle_id" json:"clientBundleId"`
	AccessToken        string             `db:"access_token" json:"accessToken"`
	RefreshToken       string             `db:"refresh_token" json:"refreshToken"`
	AccessTokenExpiry  pgtype.Timestamptz `db:"access_token_expiry" json:"accessTokenExpiry"`
	RefreshTokenExpiry pgtype.Timestamptz `db:"refresh_token_expiry" json:"refreshTokenExpiry"`
	IsDeviceApp        bool               `db:"is_device_app" json:"isDeviceApp"`
}

func (q *Queries) CreateSession(ctx context.Context, arg CreateSessionParams) (Session, error) {
	row := q.db.QueryRow(ctx, createSession,
		arg.AccountID,
		arg.ClientID,
		arg.ClientAgent,
		arg.ClientIp,
		arg.ClientBundleID,
		arg.AccessToken,
		arg.RefreshToken,
		arg.AccessTokenExpiry,
		arg.RefreshTokenExpiry,
		arg.IsDeviceApp,
	)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Modified,
		&i.Deleted,
		&i.AccountID,
		&i.ClientID,
		&i.ClientAgent,
		&i.ClientIp,
		&i.ClientBundleID,
		&i.AccessToken,
		&i.RefreshToken,
		&i.AccessTokenExpiry,
		&i.RefreshTokenExpiry,
		&i.IsDeviceApp,
	)
	return i, err
}

const deleteSession = `-- name: DeleteSession :exec
UPDATE session
SET
    deleted = now() AT TIME ZONE 'UTC'
WHERE id = $1
`

func (q *Queries) DeleteSession(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteSession, id)
	return err
}

const deleteSessionsByAccountIdClientId = `-- name: DeleteSessionsByAccountIdClientId :exec
UPDATE session
SET
    deleted = now() AT TIME ZONE 'UTC'
WHERE account_id = $1
  AND client_id = $2
`

type DeleteSessionsByAccountIdClientIdParams struct {
	AccountID pgtype.UUID `db:"account_id" json:"accountId"`
	ClientID  pgtype.UUID `db:"client_id" json:"clientId"`
}

func (q *Queries) DeleteSessionsByAccountIdClientId(ctx context.Context, arg DeleteSessionsByAccountIdClientIdParams) error {
	_, err := q.db.Exec(ctx, deleteSessionsByAccountIdClientId, arg.AccountID, arg.ClientID)
	return err
}

const getSession = `-- name: GetSession :one
SELECT id, created, modified, deleted, account_id, client_id, client_agent, client_ip, client_bundle_id, access_token, refresh_token, access_token_expiry, refresh_token_expiry, is_device_app FROM session
WHERE id = $1
  AND deleted > now() AT TIME ZONE 'UTC'
LIMIT 1
`

func (q *Queries) GetSession(ctx context.Context, id pgtype.UUID) (Session, error) {
	row := q.db.QueryRow(ctx, getSession, id)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Modified,
		&i.Deleted,
		&i.AccountID,
		&i.ClientID,
		&i.ClientAgent,
		&i.ClientIp,
		&i.ClientBundleID,
		&i.AccessToken,
		&i.RefreshToken,
		&i.AccessTokenExpiry,
		&i.RefreshTokenExpiry,
		&i.IsDeviceApp,
	)
	return i, err
}

const getSessionsByAccountIdClientId = `-- name: GetSessionsByAccountIdClientId :many
SELECT id, created, modified, deleted, account_id, client_id, client_agent, client_ip, client_bundle_id, access_token, refresh_token, access_token_expiry, refresh_token_expiry, is_device_app FROM session
WHERE account_id = $1
  AND client_id = $2
  AND deleted > now() AT TIME ZONE 'UTC'
`

type GetSessionsByAccountIdClientIdParams struct {
	AccountID pgtype.UUID `db:"account_id" json:"accountId"`
	ClientID  pgtype.UUID `db:"client_id" json:"clientId"`
}

func (q *Queries) GetSessionsByAccountIdClientId(ctx context.Context, arg GetSessionsByAccountIdClientIdParams) ([]Session, error) {
	rows, err := q.db.Query(ctx, getSessionsByAccountIdClientId, arg.AccountID, arg.ClientID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Session
	for rows.Next() {
		var i Session
		if err := rows.Scan(
			&i.ID,
			&i.Created,
			&i.Modified,
			&i.Deleted,
			&i.AccountID,
			&i.ClientID,
			&i.ClientAgent,
			&i.ClientIp,
			&i.ClientBundleID,
			&i.AccessToken,
			&i.RefreshToken,
			&i.AccessTokenExpiry,
			&i.RefreshTokenExpiry,
			&i.IsDeviceApp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSessionsByRefreshToken = `-- name: GetSessionsByRefreshToken :many
SELECT id, created, modified, deleted, account_id, client_id, client_agent, client_ip, client_bundle_id, access_token, refresh_token, access_token_expiry, refresh_token_expiry, is_device_app FROM session
WHERE refresh_token = $1
  AND deleted > now() AT TIME ZONE 'UTC'
`

func (q *Queries) GetSessionsByRefreshToken(ctx context.Context, refreshToken string) ([]Session, error) {
	rows, err := q.db.Query(ctx, getSessionsByRefreshToken, refreshToken)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Session
	for rows.Next() {
		var i Session
		if err := rows.Scan(
			&i.ID,
			&i.Created,
			&i.Modified,
			&i.Deleted,
			&i.AccountID,
			&i.ClientID,
			&i.ClientAgent,
			&i.ClientIp,
			&i.ClientBundleID,
			&i.AccessToken,
			&i.RefreshToken,
			&i.AccessTokenExpiry,
			&i.RefreshTokenExpiry,
			&i.IsDeviceApp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSessions = `-- name: ListSessions :many
SELECT id, created, modified, deleted, account_id, client_id, client_agent, client_ip, client_bundle_id, access_token, refresh_token, access_token_expiry, refresh_token_expiry, is_device_app FROM session
WHERE deleted > now() AT TIME ZONE 'UTC'
ORDER BY
    CASE
        WHEN $1::text = 'created' AND $2 = 'asc' THEN $1::text END ASC,
    CASE
        WHEN $1::text = 'created' AND $2 = 'desc' THEN $1::text END DESC

OFFSET ($3::int - 1) * $4::int
    FETCH NEXT $4 ROWS ONLY
`

type ListSessionsParams struct {
	SortBy            string      `db:"sort_by" json:"sortBy"`
	SortOrder         interface{} `db:"sort_order" json:"sortOrder"`
	RequestedPage     int32       `db:"requested_page" json:"requestedPage"`
	RequestedPageSize int32       `db:"requested_page_size" json:"requestedPageSize"`
}

func (q *Queries) ListSessions(ctx context.Context, arg ListSessionsParams) ([]Session, error) {
	rows, err := q.db.Query(ctx, listSessions,
		arg.SortBy,
		arg.SortOrder,
		arg.RequestedPage,
		arg.RequestedPageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Session
	for rows.Next() {
		var i Session
		if err := rows.Scan(
			&i.ID,
			&i.Created,
			&i.Modified,
			&i.Deleted,
			&i.AccountID,
			&i.ClientID,
			&i.ClientAgent,
			&i.ClientIp,
			&i.ClientBundleID,
			&i.AccessToken,
			&i.RefreshToken,
			&i.AccessTokenExpiry,
			&i.RefreshTokenExpiry,
			&i.IsDeviceApp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
