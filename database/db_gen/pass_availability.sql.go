// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: pass_availability.sql

package db_gen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countPassAvailabilities = `-- name: CountPassAvailabilities :one
SELECT
    COUNT(id)
FROM pass_availability
WHERE pass_id = $1
`

func (q *Queries) CountPassAvailabilities(ctx context.Context, passID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countPassAvailabilities, passID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createPassAvailability = `-- name: CreatePassAvailability :one
INSERT INTO pass_availability (
    id,
    created,
    modified,
    pass_id,
    start_date,
    end_date,
    excluded_dates,
    notes,
    is_active
) VALUES (
             uuid_generate_v4(),
             now() AT TIME ZONE 'UTC',
             now() AT TIME ZONE 'UTC',
             $1, $2, $3, $4, $5, $6
         )
RETURNING id, created, modified, pass_id, start_date, end_date, excluded_dates, notes, is_active
`

type CreatePassAvailabilityParams struct {
	PassID        pgtype.UUID          `db:"pass_id" json:"passId"`
	StartDate     pgtype.Timestamptz   `db:"start_date" json:"startDate"`
	EndDate       pgtype.Timestamptz   `db:"end_date" json:"endDate"`
	ExcludedDates []pgtype.Timestamptz `db:"excluded_dates" json:"excludedDates"`
	Notes         pgtype.Text          `db:"notes" json:"notes"`
	IsActive      bool                 `db:"is_active" json:"isActive"`
}

func (q *Queries) CreatePassAvailability(ctx context.Context, arg CreatePassAvailabilityParams) (PassAvailability, error) {
	row := q.db.QueryRow(ctx, createPassAvailability,
		arg.PassID,
		arg.StartDate,
		arg.EndDate,
		arg.ExcludedDates,
		arg.Notes,
		arg.IsActive,
	)
	var i PassAvailability
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Modified,
		&i.PassID,
		&i.StartDate,
		&i.EndDate,
		&i.ExcludedDates,
		&i.Notes,
		&i.IsActive,
	)
	return i, err
}

const deletePassAvailability = `-- name: DeletePassAvailability :exec
DELETE FROM pass_availability
WHERE id = $1
`

func (q *Queries) DeletePassAvailability(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deletePassAvailability, id)
	return err
}

const getPassAvailabilityById = `-- name: GetPassAvailabilityById :one
SELECT id, created, modified, pass_id, start_date, end_date, excluded_dates, notes, is_active FROM pass_availability
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetPassAvailabilityById(ctx context.Context, id pgtype.UUID) (PassAvailability, error) {
	row := q.db.QueryRow(ctx, getPassAvailabilityById, id)
	var i PassAvailability
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Modified,
		&i.PassID,
		&i.StartDate,
		&i.EndDate,
		&i.ExcludedDates,
		&i.Notes,
		&i.IsActive,
	)
	return i, err
}

const listPassAvailabilitiesByPassId = `-- name: ListPassAvailabilitiesByPassId :many
SELECT id, created, modified, pass_id, start_date, end_date, excluded_dates, notes, is_active FROM pass_availability
WHERE pass_id = $1
`

func (q *Queries) ListPassAvailabilitiesByPassId(ctx context.Context, passID pgtype.UUID) ([]PassAvailability, error) {
	rows, err := q.db.Query(ctx, listPassAvailabilitiesByPassId, passID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PassAvailability
	for rows.Next() {
		var i PassAvailability
		if err := rows.Scan(
			&i.ID,
			&i.Created,
			&i.Modified,
			&i.PassID,
			&i.StartDate,
			&i.EndDate,
			&i.ExcludedDates,
			&i.Notes,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePassAvailability = `-- name: UpdatePassAvailability :one
UPDATE pass_availability
SET
    modified = now() AT TIME ZONE 'UTC',
    pass_id = $2,
    start_date = $3,
    end_date = $4,
    excluded_dates = $5,
    notes = $6,
    is_active = $7
WHERE id = $1
RETURNING id, created, modified, pass_id, start_date, end_date, excluded_dates, notes, is_active
`

type UpdatePassAvailabilityParams struct {
	ID            pgtype.UUID          `db:"id" json:"id"`
	PassID        pgtype.UUID          `db:"pass_id" json:"passId"`
	StartDate     pgtype.Timestamptz   `db:"start_date" json:"startDate"`
	EndDate       pgtype.Timestamptz   `db:"end_date" json:"endDate"`
	ExcludedDates []pgtype.Timestamptz `db:"excluded_dates" json:"excludedDates"`
	Notes         pgtype.Text          `db:"notes" json:"notes"`
	IsActive      bool                 `db:"is_active" json:"isActive"`
}

func (q *Queries) UpdatePassAvailability(ctx context.Context, arg UpdatePassAvailabilityParams) (PassAvailability, error) {
	row := q.db.QueryRow(ctx, updatePassAvailability,
		arg.ID,
		arg.PassID,
		arg.StartDate,
		arg.EndDate,
		arg.ExcludedDates,
		arg.Notes,
		arg.IsActive,
	)
	var i PassAvailability
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Modified,
		&i.PassID,
		&i.StartDate,
		&i.EndDate,
		&i.ExcludedDates,
		&i.Notes,
		&i.IsActive,
	)
	return i, err
}

const upsertPassAvailability = `-- name: UpsertPassAvailability :one
INSERT INTO pass_availability (
    id,
    created,
    modified,
    pass_id,
    start_date,
    end_date,
    excluded_dates,
    notes,
    is_active
) VALUES (
             coalesce(nullif($7, uuid_nil()), uuid_generate_v4()),
             now() AT TIME ZONE 'UTC',
             now() AT TIME ZONE 'UTC',
                $1, $2, $3, $4, $5, $6
         )
ON CONFLICT (id) DO UPDATE
    SET
        modified = now() AT TIME ZONE 'UTC',
        pass_id = $1,
        start_date = $2,
        end_date = $3,
        excluded_dates = $4,
        notes = $5,
        is_active = $6
RETURNING id, created, modified, pass_id, start_date, end_date, excluded_dates, notes, is_active
`

type UpsertPassAvailabilityParams struct {
	PassID        pgtype.UUID          `db:"pass_id" json:"passId"`
	StartDate     pgtype.Timestamptz   `db:"start_date" json:"startDate"`
	EndDate       pgtype.Timestamptz   `db:"end_date" json:"endDate"`
	ExcludedDates []pgtype.Timestamptz `db:"excluded_dates" json:"excludedDates"`
	Notes         pgtype.Text          `db:"notes" json:"notes"`
	IsActive      bool                 `db:"is_active" json:"isActive"`
	ID            interface{}          `db:"id" json:"id"`
}

func (q *Queries) UpsertPassAvailability(ctx context.Context, arg UpsertPassAvailabilityParams) (PassAvailability, error) {
	row := q.db.QueryRow(ctx, upsertPassAvailability,
		arg.PassID,
		arg.StartDate,
		arg.EndDate,
		arg.ExcludedDates,
		arg.Notes,
		arg.IsActive,
		arg.ID,
	)
	var i PassAvailability
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Modified,
		&i.PassID,
		&i.StartDate,
		&i.EndDate,
		&i.ExcludedDates,
		&i.Notes,
		&i.IsActive,
	)
	return i, err
}
